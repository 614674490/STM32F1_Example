##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32               15/May/2008  12:06:32 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  thumb                                                #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  C:\David JIANG\ST MCU\Docs\STM32\AN_JIANG\TIM        #
#                       Encoder\example\FWLib\src\stm32f10x_nvic.c           #
#    Command line    =  "C:\David JIANG\ST MCU\Docs\STM32\AN_JIANG\TIM       #
#                       Encoder\example\FWLib\src\stm32f10x_nvic.c" -D       #
#                       VECT_TAB_FLASH -lcN "C:\David JIANG\ST               #
#                       MCU\Docs\STM32\AN_JIANG\TIM                          #
#                       Encoder\example\project\EWARM\BOOT_FLASH\List\" -lb  #
#                       "C:\David JIANG\ST MCU\Docs\STM32\AN_JIANG\TIM       #
#                       Encoder\example\project\EWARM\BOOT_FLASH\List\" -o   #
#                       "C:\David JIANG\ST MCU\Docs\STM32\AN_JIANG\TIM       #
#                       Encoder\example\project\EWARM\BOOT_FLASH\Obj\" -z3   #
#                       --no_cse --no_unroll --no_inline --no_code_motion    #
#                       --no_tbaa --no_clustering --no_scheduling --debug    #
#                       --cpu_mode thumb --endian little --cpu cortex-M3     #
#                       --stack_align 4 --require_prototypes --fpu None      #
#                       --dlib_config "C:\Program Files\IAR                  #
#                       Systems\Embedded Workbench                           #
#                       4.0\arm\LIB\dl7mptnnl8f.h" -I "C:\David JIANG\ST     #
#                       MCU\Docs\STM32\AN_JIANG\TIM                          #
#                       Encoder\example\project\EWARM\" -I "C:\David         #
#                       JIANG\ST MCU\Docs\STM32\AN_JIANG\TIM                 #
#                       Encoder\example\project\EWARM\..\include\" -I        #
#                       "C:\David JIANG\ST MCU\Docs\STM32\AN_JIANG\TIM       #
#                       Encoder\example\project\EWARM\..\..\FWLib\inc\" -I   #
#                       "C:\Program Files\IAR Systems\Embedded Workbench     #
#                       4.0\arm\INC\"                                        #
#    List file       =  C:\David JIANG\ST MCU\Docs\STM32\AN_JIANG\TIM        #
#                       Encoder\example\project\EWARM\BOOT_FLASH\List\stm32f #
#                       10x_nvic.lst                                         #
#    Object file     =  C:\David JIANG\ST MCU\Docs\STM32\AN_JIANG\TIM        #
#                       Encoder\example\project\EWARM\BOOT_FLASH\Obj\stm32f1 #
#                       0x_nvic.r79                                          #
#                                                                            #
#                                                                            #
##############################################################################

C:\David JIANG\ST MCU\Docs\STM32\AN_JIANG\TIM Encoder\example\FWLib\src\stm32f10x_nvic.c
      1          /******************** (C) COPYRIGHT 2007 STMicroelectronics ********************
      2          * File Name          : stm32f10x_nvic.c
      3          * Author             : MCD Application Team
      4          * Date First Issued  : 09/29/2006
      5          * Description        : This file provides all the NVIC firmware functions.
      6          ********************************************************************************
      7          * History:
      8          * 05/21/2007: V0.3
      9          * 04/02/2007: V0.2
     10          * 02/05/2007: V0.1
     11          * 09/29/2006: V0.01
     12          ********************************************************************************
     13          * THE PRESENT SOFTWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     14          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     15          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     16          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     17          * CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     18          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     19          *******************************************************************************/
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "stm32f10x_nvic.h"
     23          
     24          /* Private typedef -----------------------------------------------------------*/
     25          /* Private define ------------------------------------------------------------*/
     26          #define AIRC_VECTKEY_MASK    ((u32)0x05FA0000)
     27          
     28          /* Private macro -------------------------------------------------------------*/
     29          /* Private variables ---------------------------------------------------------*/
     30          /* Private function prototypes -----------------------------------------------*/
     31          /* Private functions ---------------------------------------------------------*/
     32          
     33          /*******************************************************************************
     34          * Function Name  : NVIC_DeInit
     35          * Description    : Deinitializes the NVIC peripheral registers to their default
     36          *                  reset values.
     37          * Input          : None
     38          * Output         : None
     39          * Return         : None
     40          *******************************************************************************/
     41          void NVIC_DeInit(void)
     42          {
     43            u32 index = 0;
     44            
     45            NVIC->Disable[0] = 0xFFFFFFFF;
     46            NVIC->Disable[1] = 0x000007FF;
     47            NVIC->Clear[0] = 0xFFFFFFFF;
     48            NVIC->Clear[1] = 0x000007FF;
     49            
     50            for(index = 0; index < 0x0B; index++)
     51            {
     52               NVIC->Priority[index] = 0x00000000;
     53            } 
     54          }
     55          
     56          /*******************************************************************************
     57          * Function Name  : NVIC_SCBDeInit
     58          * Description    : Deinitializes the SCB peripheral registers to their default 
     59          *                  reset values.
     60          * Input          : None
     61          * Output         : None
     62          * Return         : None
     63          *******************************************************************************/
     64          void NVIC_SCBDeInit(void)
     65          {
     66            u32 index = 0x00;
     67            
     68            SCB->IRQControlState = 0x0A000000;
     69            SCB->ExceptionTableOffset = 0x00000000;
     70            SCB->AIRC = AIRC_VECTKEY_MASK;
     71            SCB->SysCtrl = 0x00000000;
     72            SCB->ConfigCtrl = 0x00000000;
     73            for(index = 0; index < 0x03; index++)
     74            {
     75               SCB->SystemPriority[index] = 0;
     76            }
     77            SCB->SysHandlerCtrl = 0x00000000;
     78            SCB->ConfigFaultStatus = 0xFFFFFFFF;
     79            SCB->HardFaultStatus = 0xFFFFFFFF;
     80            SCB->DebugFaultStatus = 0xFFFFFFFF;
     81          }
     82          
     83          /*******************************************************************************
     84          * Function Name  : NVIC_PriorityGroupConfig
     85          * Description    : Configures the priority grouping: pre-emption priority
     86          *                  and subpriority.
     87          * Input          : - NVIC_PriorityGroup: specifies the priority grouping bits
     88          *                    length. This parameter can be one of the following values:
     89          *                       - NVIC_PriorityGroup_0: 0 bits for pre-emption priority
     90          *                         4 bits for subpriority
     91          *                       - NVIC_PriorityGroup_1: 1 bits for pre-emption priority
     92          *                         3 bits for subpriority
     93          *                       - NVIC_PriorityGroup_2: 2 bits for pre-emption priority
     94          *                         2 bits for subpriority
     95          *                       - NVIC_PriorityGroup_3: 3 bits for pre-emption priority
     96          *                         1 bits for subpriority
     97          *                       - NVIC_PriorityGroup_4: 4 bits for pre-emption priority
     98          *                         0 bits for subpriority
     99          * Output         : None
    100          * Return         : None
    101          *******************************************************************************/
    102          void NVIC_PriorityGroupConfig(u32 NVIC_PriorityGroup)
    103          {
    104            /* Check the parameters */
    105            assert(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
    106            
    107            /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
    108            SCB->AIRC = AIRC_VECTKEY_MASK | NVIC_PriorityGroup;
    109          }
    110          
    111          /*******************************************************************************
    112          * Function Name  : NVIC_Init
    113          * Description    : Initializes the NVIC peripheral according to the specified
    114          *                  parameters in the NVIC_InitStruct.
    115          * Input          : - NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure
    116          *                    that contains the configuration information for the
    117          *                    specified NVIC peripheral.
    118          * Output         : None
    119          * Return         : None
    120          *******************************************************************************/
    121          void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)
    122          {
    123            u32 tmppriority = 0x00, tmpreg = 0x00, tmpmask = 0x00;
    124            u32 tmppre = 0, tmpsub = 0x0F;
    125          
    126            /* Check the parameters */
    127            assert(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
    128            assert(IS_NVIC_IRQ_CHANNEL(NVIC_InitStruct->NVIC_IRQChannel));
    129            assert(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
    130            assert(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    131              
    132            if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
    133            {
    134              /* Compute the Corresponding IRQ Priority --------------------------------*/    
    135              tmppriority = (0x700 - (SCB->AIRC & (u32)0x700))>> 0x08;
    136              tmppre = (0x4 - tmppriority);
    137              tmpsub = tmpsub >> tmppriority;
    138              
    139              tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    140              tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
    141          
    142              tmppriority = tmppriority << 0x04;
    143              tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    144              
    145              tmpreg = NVIC->Priority[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
    146              tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    147              tmpreg &= ~tmpmask;
    148              tmppriority &= tmpmask;  
    149              tmpreg |= tmppriority;
    150          
    151              NVIC->Priority[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;
    152              
    153              /* Enable the Selected IRQ Channels --------------------------------------*/
    154              NVIC->Enable[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
    155                (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
    156            }
    157            else
    158            {
    159              /* Disable the Selected IRQ Channels -------------------------------------*/
    160              NVIC->Disable[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
    161                (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
    162            }
    163          }
    164          
    165          /*******************************************************************************
    166          * Function Name  : NVIC_StructInit
    167          * Description    : Fills each NVIC_InitStruct member with its default value.
    168          * Input          : - NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure which
    169          *                    will be initialized.
    170          * Output         : None
    171          * Return         : None
    172          *******************************************************************************/
    173          void NVIC_StructInit(NVIC_InitTypeDef* NVIC_InitStruct)
    174          {
    175            /* NVIC_InitStruct members default value */
    176            NVIC_InitStruct->NVIC_IRQChannel = 0x00;
    177            NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority = 0x00;
    178            NVIC_InitStruct->NVIC_IRQChannelSubPriority = 0x00;
    179            NVIC_InitStruct->NVIC_IRQChannelCmd = DISABLE;
    180          }
    181          
    182          /*******************************************************************************
    183          * Function Name  : NVIC_SETPRIMASK
    184          * Description    : Enables the PRIMASK priority: Raises the execution priority to 0.
    185          * Input          : None
    186          * Output         : None
    187          * Return         : None
    188          *******************************************************************************/
    189          void NVIC_SETPRIMASK(void)
    190          {
    191            __SETPRIMASK();
    192          }
    193          
    194          /*******************************************************************************
    195          * Function Name  : NVIC_RESETPRIMASK
    196          * Description    : Disables the PRIMASK priority.
    197          * Input          : None
    198          * Output         : None
    199          * Return         : None
    200          *******************************************************************************/
    201          void NVIC_RESETPRIMASK(void)
    202          {
    203            __RESETPRIMASK();
    204          }
    205          
    206          /*******************************************************************************
    207          * Function Name  : NVIC_SETFAULTMASK
    208          * Description    : Enables the FAULTMASK priority: Raises the execution priority to -1.
    209          * Input          : None
    210          * Output         : None
    211          * Return         : None
    212          *******************************************************************************/
    213          void NVIC_SETFAULTMASK(void)
    214          {
    215            __SETFAULTMASK();
    216          }
    217          
    218          /*******************************************************************************
    219          * Function Name  : NVIC_RESETFAULTMASK
    220          * Description    : Disables the FAULTMASK priority.
    221          * Input          : None
    222          * Output         : None
    223          * Return         : None
    224          *******************************************************************************/
    225          void NVIC_RESETFAULTMASK(void)
    226          {
    227            __RESETFAULTMASK();
    228          }
    229          
    230          /*******************************************************************************
    231          * Function Name  : NVIC_BASEPRICONFIG
    232          * Description    : The execution priority can be changed from 15 (lowest 
    233                             configurable priority) to 1.
    234          * Input          : None
    235          * Output         : None
    236          * Return         : None
    237          *******************************************************************************/
    238          void NVIC_BASEPRICONFIG(u32 NewPriority)
    239          {
    240            /* Check the parameters */
    241            assert(IS_NVIC_BASE_PRI(NewPriority));
    242            
    243            __BASEPRICONFIG(NewPriority << 0x04);
    244          }
    245          
    246          /*******************************************************************************
    247          * Function Name  : NVIC_GetBASEPRI
    248          * Description    : Returns the BASEPRI mask value.
    249          * Input          : None
    250          * Output         : None
    251          * Return         : BASEPRI register value
    252          *******************************************************************************/
    253          u32 NVIC_GetBASEPRI(void)
    254          {
    255            return (__GetBASEPRI());
    256          }
    257          
    258          /*******************************************************************************
    259          * Function Name  : NVIC_GetCurrentPendingIRQChannel
    260          * Description    : Returns the current pending IRQ channel identifier.
    261          * Input          : None
    262          * Output         : None
    263          * Return         : Pending IRQ Channel Identifier.
    264          *******************************************************************************/
    265          u16 NVIC_GetCurrentPendingIRQChannel(void)
    266          {
    267            return ((u16)((SCB->IRQControlState & (u32)0x003FF000) >> 0x0C));
    268          }
    269          
    270          /*******************************************************************************
    271          * Function Name  : NVIC_GetIRQChannelPendingBitStatus
    272          * Description    : Checks whether the specified IRQ Channel pending bit is set
    273          *                  or not.
    274          * Input          : - NVIC_IRQChannel: specifies the interrupt pending bit to check.
    275          * Output         : None
    276          * Return         : The new state of IRQ Channel pending bit(SET or RESET).
    277          *******************************************************************************/
    278          ITStatus NVIC_GetIRQChannelPendingBitStatus(u8 NVIC_IRQChannel)
    279          {
    280            ITStatus pendingirqstatus = RESET;
    281            u32 tmp = 0x00;
    282            
    283            /* Check the parameters */
    284            assert(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
    285            
    286            tmp = ((u32)0x01 << (NVIC_IRQChannel & (u32)0x1F));
    287          
    288            if (((NVIC->Set[(NVIC_IRQChannel >> 0x05)]) & tmp) == tmp)
    289            {
    290              pendingirqstatus = SET;
    291            }
    292            else
    293            {
    294              pendingirqstatus = RESET;
    295            }
    296            return pendingirqstatus;
    297          }
    298          
    299          /*******************************************************************************
    300          * Function Name  : NVIC_SetIRQChannelPendingBit
    301          * Description    : Sets the NVIC’s interrupt pending bit.
    302          * Input          : - NVIC_IRQChannel: specifies the interrupt pending bit to Set.
    303          * Output         : None
    304          * Return         : None
    305          *******************************************************************************/
    306          void NVIC_SetIRQChannelPendingBit(u8 NVIC_IRQChannel)
    307          {
    308            /* Check the parameters */
    309            assert(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
    310            
    311            *(u32*)0xE000EF00 = (u32)NVIC_IRQChannel;
    312          }
    313          
    314          /*******************************************************************************
    315          * Function Name  : NVIC_ClearIRQChannelPendingBit
    316          * Description    : Clears the NVIC’s interrupt pending bit.
    317          * Input          : - NVIC_IRQChannel: specifies the interrupt pending bit to clear.
    318          * Output         : None
    319          * Return         : None
    320          *******************************************************************************/
    321          void NVIC_ClearIRQChannelPendingBit(u8 NVIC_IRQChannel)
    322          {
    323            /* Check the parameters */
    324            assert(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
    325            
    326            NVIC->Clear[(NVIC_IRQChannel >> 0x05)] = (u32)0x01 << (NVIC_IRQChannel & (u32)0x1F);
    327          }
    328          
    329          /*******************************************************************************
    330          * Function Name  : NVIC_GetCurrentActiveHandler
    331          * Description    : Returns the current active Handler (IRQ Channel and
    332          *                  SystemHandler) identifier.
    333          * Input          : None
    334          * Output         : None
    335          * Return         : Active Handler Identifier.
    336          *******************************************************************************/
    337          u16 NVIC_GetCurrentActiveHandler(void)
    338          {
    339            return ((u16)(SCB->IRQControlState & (u32)0x3FF));
    340          }
    341          
    342          /*******************************************************************************
    343          * Function Name  : NVIC_GetIRQChannelActiveBitStatus
    344          * Description    : Checks whether the specified IRQ Channel active bit is set
    345          *                  or not.
    346          * Input          : - NVIC_IRQChannel: specifies the interrupt active bit to check.
    347          * Output         : None
    348          * Return         : The new state of IRQ Channel active bit(SET or RESET).
    349          *******************************************************************************/
    350          ITStatus NVIC_GetIRQChannelActiveBitStatus(u8 NVIC_IRQChannel)
    351          {
    352            ITStatus activeirqstatus = RESET;
    353            u32 tmp = 0x00;
    354          
    355            /* Check the parameters */
    356            assert(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
    357            
    358            tmp = ((u32)0x01 << (NVIC_IRQChannel & (u32)0x1F));
    359          
    360            if (((NVIC->Active[(NVIC_IRQChannel >> 0x05)]) & tmp) == tmp )
    361            {
    362              activeirqstatus = SET;
    363            }
    364            else
    365            {
    366              activeirqstatus = RESET;
    367            }
    368            return activeirqstatus;
    369          }
    370          
    371          /*******************************************************************************
    372          * Function Name  : NVIC_GetCPUID
    373          * Description    : Returns the ID number, the version number and the implementation
    374          *                  details of the Cortex-M3 core.
    375          * Input          : None
    376          * Output         : None
    377          * Return         : CPU ID.
    378          *******************************************************************************/
    379          u32 NVIC_GetCPUID(void)
    380          {
    381            return (SCB->CPUID);
    382          }
    383          
    384          /*******************************************************************************
    385          * Function Name  : NVIC_SetVectorTable
    386          * Description    : Sets the vector table location and Offset.
    387          * Input          : - NVIC_VectTab: specifies if the vector table is in RAM or
    388          *                    FLASH memory.
    389          *                    This parameter can be one of the following values:
    390          *                       - NVIC_VectTab_RAM
    391          *                       - NVIC_VectTab_FLASH
    392          *                  - Offset: Vector Table base offset field. 
    393          *                            This value must be a multiple of 0x100.
    394          * Output         : None
    395          * Return         : None
    396          *******************************************************************************/
    397          void NVIC_SetVectorTable(u32 NVIC_VectTab, u32 Offset)
    398          { 
    399            /* Check the parameters */
    400            assert(IS_NVIC_VECTTAB(NVIC_VectTab));
    401            assert(IS_NVIC_OFFSET(Offset));  
    402             
    403            SCB->ExceptionTableOffset = NVIC_VectTab | (Offset & (u32)0x1FFFFF80);
    404          }
    405          
    406          /*******************************************************************************
    407          * Function Name  : NVIC_GenerateSystemReset
    408          * Description    : Generates a system reset.
    409          * Input          : None
    410          * Output         : None
    411          * Return         : None
    412          *******************************************************************************/
    413          void NVIC_GenerateSystemReset(void)
    414          {
    415            SCB->AIRC = AIRC_VECTKEY_MASK | (u32)0x04;
    416          }
    417          
    418          /*******************************************************************************
    419          * Function Name  : NVIC_GenerateCoreReset
    420          * Description    : Generates a Core (Core + NVIC) reset.
    421          * Input          : None
    422          * Output         : None
    423          * Return         : None
    424          *******************************************************************************/
    425          void NVIC_GenerateCoreReset(void)
    426          {
    427            SCB->AIRC = AIRC_VECTKEY_MASK | (u32)0x01;
    428          }
    429          
    430          /*******************************************************************************
    431          * Function Name  : NVIC_SystemLPConfig
    432          * Description    : Selects the condition for the system to enter low power mode.
    433          * Input          : - LowPowerMode: Specifies the new mode for the system to enter
    434          *                    low power mode.
    435          *                    This parameter can be one of the following values:
    436          *                       - NVIC_LP_SEVONPEND
    437          *                       - NVIC_LP_SLEEPDEEP
    438          *                       - NVIC_LP_SLEEPONEXIT
    439          *                  - NewState: new state of LP condition.
    440          *                    This parameter can be: ENABLE or DISABLE.
    441          * Output         : None
    442          * Return         : None
    443          *******************************************************************************/
    444          void NVIC_SystemLPConfig(u8 LowPowerMode, FunctionalState NewState)
    445          {
    446            /* Check the parameters */
    447            assert(IS_NVIC_LP(LowPowerMode));
    448            assert(IS_FUNCTIONAL_STATE(NewState));  
    449            
    450            if (NewState != DISABLE)
    451            {
    452              SCB->SysCtrl |= LowPowerMode;
    453            }
    454            else
    455            {
    456              SCB->SysCtrl &= (u32)(~(u32)LowPowerMode);
    457            }
    458          }
    459          
    460          /*******************************************************************************
    461          * Function Name  : NVIC_SystemHandlerConfig
    462          * Description    : Enables or disables the specified System Handlers.
    463          * Input          : - SystemHandler: specifies the system handler to be enabled
    464          *                    or disabled.
    465          *                    This parameter can be one of the following values:
    466          *                       - SystemHandler_MemoryManage
    467          *                       - SystemHandler_BusFault
    468          *                       - SystemHandler_UsageFault
    469          *                  - NewState: new state of  specified System Handlers.
    470          *                    This parameter can be: ENABLE or DISABLE.
    471          * Output         : None
    472          * Return         : None
    473          *******************************************************************************/
    474          void NVIC_SystemHandlerConfig(u32 SystemHandler, FunctionalState NewState)
    475          {
    476            u32 tmpreg = 0x00;
    477          
    478            /* Check the parameters */
    479            assert(IS_CONFIG_SYSTEM_HANDLER(SystemHandler));
    480            assert(IS_FUNCTIONAL_STATE(NewState)); 
    481            
    482            tmpreg =  (u32)0x01 << (SystemHandler & (u32)0x1F);
    483          
    484            if (NewState != DISABLE)
    485            {
    486              SCB->SysHandlerCtrl |= tmpreg;
    487            }
    488            else
    489            {
    490              SCB->SysHandlerCtrl &= ~tmpreg;
    491            }
    492          }
    493          
    494          /*******************************************************************************
    495          * Function Name  : NVIC_SystemHandlerPriorityConfig
    496          * Description    : Configures the specified System Handlers priority.
    497          * Input          : - SystemHandler: specifies the system handler to be
    498          *                    enabled or disabled.
    499          *                    This parameter can be one of the following values:
    500          *                       - SystemHandler_MemoryManage
    501          *                       - SystemHandler_BusFault
    502          *                       - SystemHandler_UsageFault
    503          *                       - SystemHandler_SVCall
    504          *                       - SystemHandler_DebugMonitor
    505          *                       - SystemHandler_PSV
    506          *                       - SystemHandler_SysTick
    507          *                  - SystemHandlerPreemptionPriority: new priority group of the
    508          *                    specified system handlers.
    509          *                  - SystemHandlerSubPriority: new sub priority of the specified
    510          *                    system handlers.
    511          * Output         : None
    512          * Return         : None
    513          *******************************************************************************/
    514          void NVIC_SystemHandlerPriorityConfig(u32 SystemHandler, u8 SystemHandlerPreemptionPriority,
    515                                                u8 SystemHandlerSubPriority)
    516          {
    517            u32 tmp1 = 0x00, tmp2 = 0xFF, handlermask = 0x00;
    518            u32 tmppriority = 0x00;
    519          
    520            /* Check the parameters */
    521            assert(IS_PRIORITY_SYSTEM_HANDLER(SystemHandler));
    522            assert(IS_NVIC_PREEMPTION_PRIORITY(SystemHandlerPreemptionPriority));  
    523            assert(IS_NVIC_SUB_PRIORITY(SystemHandlerSubPriority));
    524              
    525            tmppriority = (0x700 - (SCB->AIRC & (u32)0x700))>> 0x08;
    526            tmp1 = (0x4 - tmppriority);
    527            tmp2 = tmp2 >> tmppriority;
    528              
    529            tmppriority = (u32)SystemHandlerPreemptionPriority << tmp1;
    530            tmppriority |=  SystemHandlerSubPriority & tmp2;
    531          
    532            tmppriority = tmppriority << 0x04;
    533            tmp1 = SystemHandler & (u32)0xC0;
    534            tmp1 = tmp1 >> 0x06; 
    535            tmp2 = (SystemHandler >> 0x08) & (u32)0x03;
    536            tmppriority = tmppriority << (tmp2 * 0x08);
    537            handlermask = (u32)0xFF << (tmp2 * 0x08);
    538            
    539            SCB->SystemPriority[tmp1] &= ~handlermask;
    540            SCB->SystemPriority[tmp1] |= tmppriority;
    541          }
    542          
    543          /*******************************************************************************
    544          * Function Name  : NVIC_GetSystemHandlerPendingBitStatus
    545          * Description    : Checks whether the specified System handlers pending bit is
    546          *                  set or not.
    547          * Input          : - SystemHandler: specifies the system handler pending bit to
    548          *                    check.
    549          *                    This parameter can be one of the following values:
    550          *                       - SystemHandler_MemoryManage
    551          *                       - SystemHandler_BusFault
    552          *                       - SystemHandler_SVCall
    553          * Output         : None
    554          * Return         : The new state of System Handler pending bit(SET or RESET).
    555          *******************************************************************************/
    556          ITStatus NVIC_GetSystemHandlerPendingBitStatus(u32 SystemHandler)
    557          {
    558            ITStatus bitstatus  = RESET;
    559            u32 tmp = 0x00, tmppos = 0x00;
    560          
    561            /* Check the parameters */
    562            assert(IS_GET_PENDING_SYSTEM_HANDLER(SystemHandler));
    563            
    564            tmppos = (SystemHandler >> 0x0A);
    565            tmppos &= (u32)0x0F;
    566          
    567            tmppos = (u32)0x01 << tmppos;
    568          
    569            tmp = SCB->SysHandlerCtrl & tmppos;
    570          
    571            if (tmp == tmppos)
    572            {
    573              bitstatus = SET;
    574            }
    575            else
    576            {
    577              bitstatus = RESET;
    578            }
    579            return bitstatus;
    580          }
    581          
    582          /*******************************************************************************
    583          * Function Name  : NVIC_SetSystemHandlerPendingBit
    584          * Description    : Sets System Handler pending bit.
    585          * Input          : - SystemHandler: specifies the system handler pending bit
    586          *                    to be set.
    587          *                    This parameter can be one of the following values:
    588          *                       - SystemHandler_NMI
    589          *                       - SystemHandler_PSV
    590          *                       - SystemHandler_SysTick
    591          * Output         : None
    592          * Return         : None
    593          *******************************************************************************/
    594          void NVIC_SetSystemHandlerPendingBit(u32 SystemHandler)
    595          {
    596            u32 tmp = 0x00;
    597          
    598            /* Check the parameters */
    599            assert(IS_SET_PENDING_SYSTEM_HANDLER(SystemHandler));
    600            
    601            /* Get the System Handler pending bit position */
    602            tmp = SystemHandler & (u32)0x1F;
    603            /* Set the corresponding System Handler pending bit */
    604            SCB->IRQControlState |= ((u32)0x01 << tmp);
    605          }
    606          
    607          /*******************************************************************************
    608          * Function Name  : NVIC_ClearSystemHandlerPendingBit
    609          * Description    : Clears System Handler pending bit.
    610          * Input          : - SystemHandler: specifies the system handler pending bit to
    611          *                    be clear.
    612          *                    This parameter can be one of the following values:
    613          *                       - SystemHandler_PSV
    614          *                       - SystemHandler_SysTick
    615          * Output         : None
    616          * Return         : None
    617          *******************************************************************************/
    618          void NVIC_ClearSystemHandlerPendingBit(u32 SystemHandler)
    619          {
    620            u32 tmp = 0x00;
    621          
    622            /* Check the parameters */
    623            assert(IS_CLEAR_SYSTEM_HANDLER(SystemHandler));
    624            
    625            /* Get the System Handler pending bit position */
    626            tmp = SystemHandler & (u32)0x1F;
    627            /* Clear the corresponding System Handler pending bit */
    628            SCB->IRQControlState |= ((u32)0x01 << (tmp - 0x01));
    629          }
    630          
    631          /*******************************************************************************
    632          * Function Name  : NVIC_GetSystemHandlerActiveBitStatus
    633          * Description    : Checks whether the specified System handlers active bit is
    634          *                  set or not.
    635          * Input          : - SystemHandler: specifies the system handler active bit to
    636          *                    check.
    637          *                    This parameter can be one of the following values:
    638          *                       - SystemHandler_MemoryManage
    639          *                       - SystemHandler_BusFault
    640          *                       - SystemHandler_UsageFault
    641          *                       - SystemHandler_SVCall
    642          *                       - SystemHandler_DebugMonitor
    643          *                       - SystemHandler_PSV
    644          *                       - SystemHandler_SysTick
    645          * Output         : None
    646          * Return         : The new state of System Handler active bit(SET or RESET).
    647          *******************************************************************************/
    648          ITStatus NVIC_GetSystemHandlerActiveBitStatus(u32 SystemHandler)
    649          {
    650            ITStatus bitstatus  = RESET;
    651          
    652            u32 tmp = 0x00, tmppos = 0x00;
    653          
    654            /* Check the parameters */
    655            assert(IS_GET_ACTIVE_SYSTEM_HANDLER(SystemHandler));
    656            
    657            tmppos = (SystemHandler >> 0x0E) & (u32)0x0F;
    658          
    659            tmppos = (u32)0x01 << tmppos;
    660          
    661            tmp = SCB->SysHandlerCtrl & tmppos;
    662          
    663            if (tmp == tmppos)
    664            {
    665              bitstatus = SET;
    666            }
    667            else
    668            {
    669              bitstatus = RESET;
    670            }
    671            return bitstatus;
    672          }
    673          
    674          /*******************************************************************************
    675          * Function Name  : NVIC_GetFaultHandlerSources
    676          * Description    : Returns the system fault handlers sources.
    677          * Input          : - SystemHandler: specifies the system handler to get its fault
    678          *                    sources.
    679          *                    This parameter can be one of the following values:
    680          *                       - SystemHandler_HardFault
    681          *                       - SystemHandler_MemoryManage
    682          *                       - SystemHandler_BusFault
    683          *                       - SystemHandler_UsageFault
    684          *                       - SystemHandler_DebugMonitor
    685          * Output         : None
    686          * Return         : Source of the fault handler.
    687          *******************************************************************************/
    688          u32 NVIC_GetFaultHandlerSources(u32 SystemHandler)
    689          {
    690            u32 faultsources = 0x00;
    691            u32 tmpreg = 0x00, tmppos = 0x00;
    692          
    693            /* Check the parameters */
    694            assert(IS_FAULT_SOURCE_SYSTEM_HANDLER(SystemHandler));
    695            
    696            tmpreg = (SystemHandler >> 0x12) & (u32)0x03;
    697            tmppos = (SystemHandler >> 0x14) & (u32)0x03;
    698          
    699            if (tmpreg == 0x00)
    700            {
    701              faultsources = SCB->HardFaultStatus;
    702            }
    703            else if (tmpreg == 0x01)
    704            {
    705              faultsources = SCB->ConfigFaultStatus >> (tmppos * 0x08);
    706              if (tmppos != 0x02)
    707              {
    708                faultsources &= (u32)0x0F;
    709              }
    710              else
    711              {
    712                faultsources &= (u32)0xFF;
    713              }
    714            }
    715            else
    716            {
    717              faultsources = SCB->DebugFaultStatus;
    718            }
    719            return faultsources;
    720          }
    721          
    722          /*******************************************************************************
    723          * Function Name  : NVIC_GetFaultAddress
    724          * Description    : Returns the address of the location that generated a fault
    725          *                  handler.
    726          * Input          : - SystemHandler: specifies the system handler to get its
    727          *                    fault address.
    728          *                    This parameter can be one of the following values:
    729          *                       - SystemHandler_MemoryManage
    730          *                       - SystemHandler_BusFault
    731          * Output         : None
    732          * Return         : Fault address.
    733          *******************************************************************************/
    734          u32 NVIC_GetFaultAddress(u32 SystemHandler)
    735          {
    736            u32 faultaddress = 0x00;
    737            u32 tmp = 0x00;
    738          
    739            /* Check the parameters */
    740            assert(IS_FAULT_ADDRESS_SYSTEM_HANDLER(SystemHandler));
    741            
    742            tmp = (SystemHandler >> 0x16) & (u32)0x01;
    743          
    744            if (tmp == 0x00)
    745            {
    746              faultaddress = SCB->MemoryManageFaultAddr;
    747            }
    748            else
    749            {
    750              faultaddress = SCB->BusFaultAddr;
    751            }
    752            return faultaddress;
    753          }
    754          
    755          /******************* (C) COPYRIGHT 2007 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function                       CSTACK
     --------                       ------
     NVIC_BASEPRICONFIG                 8
     NVIC_ClearIRQChannelPendingBit     8
     NVIC_ClearSystemHandlerPendingBit
                                        8
     NVIC_DeInit                        0
     NVIC_GenerateCoreReset             0
     NVIC_GenerateSystemReset           0
     NVIC_GetBASEPRI                    4
     NVIC_GetCPUID                      0
     NVIC_GetCurrentActiveHandler       0
     NVIC_GetCurrentPendingIRQChannel
                                        0
     NVIC_GetFaultAddress               8
     NVIC_GetFaultHandlerSources        8
     NVIC_GetIRQChannelActiveBitStatus
                                        8
     NVIC_GetIRQChannelPendingBitStatus
                                        8
     NVIC_GetSystemHandlerActiveBitStatus
                                        8
     NVIC_GetSystemHandlerPendingBitStatus
                                        8
     NVIC_Init                         16
     NVIC_PriorityGroupConfig           8
     NVIC_RESETFAULTMASK                4
     NVIC_RESETPRIMASK                  4
     NVIC_SCBDeInit                     0
     NVIC_SETFAULTMASK                  4
     NVIC_SETPRIMASK                    4
     NVIC_SetIRQChannelPendingBit       8
     NVIC_SetSystemHandlerPendingBit
                                        8
     NVIC_SetVectorTable               12
     NVIC_StructInit                    0
     NVIC_SystemHandlerConfig          12
     NVIC_SystemHandlerPriorityConfig
                                       20
     NVIC_SystemLPConfig               12


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     NVIC_DeInit                      80
     NVIC_SCBDeInit                  110
     NVIC_PriorityGroupConfig         54
     NVIC_Init                       506
     NVIC_StructInit                  18
     NVIC_SETPRIMASK                   8
     NVIC_RESETPRIMASK                 8
     NVIC_SETFAULTMASK                 8
     NVIC_RESETFAULTMASK               8
     NVIC_BASEPRICONFIG               28
     NVIC_GetBASEPRI                   8
     NVIC_GetCurrentPendingIRQChannel
                                      24
     NVIC_GetIRQChannelPendingBitStatus
                                     230
     NVIC_SetIRQChannelPendingBit    200
     NVIC_ClearIRQChannelPendingBit  218
     NVIC_GetCurrentActiveHandler     12
     NVIC_GetIRQChannelActiveBitStatus
                                     230
     NVIC_GetCPUID                     8
     NVIC_SetVectorTable              68
     NVIC_GenerateSystemReset         16
     NVIC_GenerateCoreReset           16
     NVIC_SystemLPConfig              84
     NVIC_SystemHandlerConfig        100
     NVIC_SystemHandlerPriorityConfig
                                     224
     NVIC_GetSystemHandlerPendingBitStatus
                                      76
     NVIC_SetSystemHandlerPendingBit
                                      60
     NVIC_ClearSystemHandlerPendingBit
                                      56
     NVIC_GetSystemHandlerActiveBitStatus
                                     100
     NVIC_GetFaultHandlerSources     120
     NVIC_GetFaultAddress             58
     ??DataTable18                     4
     ??DataTable27                     4
     ??DataTable28                     4
     ??DataTable29                     4
     ??DataTable36                     4
     ??DataTable37                     4
     ??DataTable58                     4
     ??DataTable86                     4
     ??DataTable89                     4
     ??DataTable90                     4
     ??DataTable91                     4
     ??DataTable92                     4
     ??DataTable94                     4
     ??DataTable95                     4
     ??DataTable100                    4
     ??DataTable101                    4
     ??DataTable106                    4
     ??DataTable107                    4
     ??DataTable108                    4
     ??DataTable110                    4
     ?<Constant "C:\\David JIANG\\ST MCU...">
                                      92
      Others                          56

 
 2 872 bytes in segment CODE
    92 bytes in segment DATA_C
 
 2 816 bytes of CODE  memory (+ 56 bytes shared)
    92 bytes of CONST memory

Errors: none
Warnings: none
