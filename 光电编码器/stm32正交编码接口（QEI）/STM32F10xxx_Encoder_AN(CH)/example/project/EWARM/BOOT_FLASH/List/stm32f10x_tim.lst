##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32               15/May/2008  12:06:33 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  thumb                                                #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  C:\David JIANG\ST MCU\Docs\STM32\AN_JIANG\TIM        #
#                       Encoder\example\FWLib\src\stm32f10x_tim.c            #
#    Command line    =  "C:\David JIANG\ST MCU\Docs\STM32\AN_JIANG\TIM       #
#                       Encoder\example\FWLib\src\stm32f10x_tim.c" -D        #
#                       VECT_TAB_FLASH -lcN "C:\David JIANG\ST               #
#                       MCU\Docs\STM32\AN_JIANG\TIM                          #
#                       Encoder\example\project\EWARM\BOOT_FLASH\List\" -lb  #
#                       "C:\David JIANG\ST MCU\Docs\STM32\AN_JIANG\TIM       #
#                       Encoder\example\project\EWARM\BOOT_FLASH\List\" -o   #
#                       "C:\David JIANG\ST MCU\Docs\STM32\AN_JIANG\TIM       #
#                       Encoder\example\project\EWARM\BOOT_FLASH\Obj\" -z3   #
#                       --no_cse --no_unroll --no_inline --no_code_motion    #
#                       --no_tbaa --no_clustering --no_scheduling --debug    #
#                       --cpu_mode thumb --endian little --cpu cortex-M3     #
#                       --stack_align 4 --require_prototypes --fpu None      #
#                       --dlib_config "C:\Program Files\IAR                  #
#                       Systems\Embedded Workbench                           #
#                       4.0\arm\LIB\dl7mptnnl8f.h" -I "C:\David JIANG\ST     #
#                       MCU\Docs\STM32\AN_JIANG\TIM                          #
#                       Encoder\example\project\EWARM\" -I "C:\David         #
#                       JIANG\ST MCU\Docs\STM32\AN_JIANG\TIM                 #
#                       Encoder\example\project\EWARM\..\include\" -I        #
#                       "C:\David JIANG\ST MCU\Docs\STM32\AN_JIANG\TIM       #
#                       Encoder\example\project\EWARM\..\..\FWLib\inc\" -I   #
#                       "C:\Program Files\IAR Systems\Embedded Workbench     #
#                       4.0\arm\INC\"                                        #
#    List file       =  C:\David JIANG\ST MCU\Docs\STM32\AN_JIANG\TIM        #
#                       Encoder\example\project\EWARM\BOOT_FLASH\List\stm32f #
#                       10x_tim.lst                                          #
#    Object file     =  C:\David JIANG\ST MCU\Docs\STM32\AN_JIANG\TIM        #
#                       Encoder\example\project\EWARM\BOOT_FLASH\Obj\stm32f1 #
#                       0x_tim.r79                                           #
#                                                                            #
#                                                                            #
##############################################################################

C:\David JIANG\ST MCU\Docs\STM32\AN_JIANG\TIM Encoder\example\FWLib\src\stm32f10x_tim.c
      1          /******************** (C) COPYRIGHT 2007 STMicroelectronics ********************
      2          * File Name          : stm32f10x_tim.c
      3          * Author             : MCD Application Team
      4          * Date First Issued  : 09/29/2006
      5          * Description        : This file provides all the TIM firmware functions.
      6          ********************************************************************************
      7          * History:
      8          * 05/21/2007: V0.3
      9          * 04/02/2007: V0.2
     10          * 02/05/2007: V0.1
     11          * 09/29/2006: V0.01
     12          ********************************************************************************
     13          * THE PRESENT SOFTWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     14          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     15          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     16          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     17          * CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     18          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     19          *******************************************************************************/
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "stm32f10x_tim.h"
     23          #include "stm32f10x_rcc.h"
     24          
     25          /* Private typedef -----------------------------------------------------------*/
     26          /* Private define ------------------------------------------------------------*/
     27          /* ---------------------- TIM registers bit mask ------------------------ */
     28          #define CR1_CEN_Set                 ((u16)0x0001)
     29          #define CR1_CEN_Reset               ((u16)0x03FE)
     30          #define CR1_UDIS_Set                ((u16)0x0002)
     31          #define CR1_UDIS_Reset              ((u16)0x03FD)
     32          #define CR1_URS_Set                 ((u16)0x0004)
     33          #define CR1_URS_Reset               ((u16)0x03FB)
     34          #define CR1_OPM_Mask                ((u16)0x03F7)
     35          #define CR1_CounterMode_Mask        ((u16)0x039F)
     36          #define CR1_ARPE_Set                ((u16)0x0080)
     37          #define CR1_ARPE_Reset              ((u16)0x037F)
     38          #define CR1_CKD_Mask                ((u16)0x00FF)
     39          
     40          #define CR2_CCDS_Set                ((u16)0x0008)
     41          #define CR2_CCDS_Reset              ((u16)0x0007)
     42          #define CR2_MMS_Mask                ((u16)0x0080)
     43          #define CR2_TI1S_Set                ((u16)0x0080)
     44          #define CR2_TI1S_Reset              ((u16)0xFF70)
     45          
     46          #define SMCR_SMS_Mask               ((u16)0xFFF0)
     47          #define SMCR_ETR_Mask               ((u16)0x00F7)
     48          #define SMCR_TS_Mask                ((u16)0xFF87)
     49          #define SMCR_MSM_Mask               ((u16)0xFF77)
     50          #define SMCR_ECE_Set                ((u16)0x4000)
     51          
     52          #define CCMR_CC13S_Mask             ((u16)0x7F7C)
     53          #define CCMR_CC24S_Mask             ((u16)0x7C7F)
     54          #define CCMR_TI13Direct_Set         ((u16)0x0001)
     55          #define CCMR_TI24Direct_Set         ((u16)0x0100)
     56          #define CCMR_OC13FE_Mask            ((u16)0x7F7B)
     57          #define CCMR_OC24FE_Mask            ((u16)0x7B7F)
     58          #define CCMR_OC13PE_Mask            ((u16)0x7F77)
     59          #define CCMR_OC24PE_Mask            ((u16)0x777F)
     60          #define CCMR_OCM13_Mask             ((u16)0x7F0F)
     61          #define CCMR_OCM24_Mask             ((u16)0x0F7F)
     62          
     63          #define CCMR_OC13CE_Mask            ((u16)0xFF7F)
     64          #define CCMR_OC24CE_Mask            ((u16)0x7FFF)
     65          
     66          #define CCMR_IC13PSC_Mask           ((u16)0xFFF3)
     67          #define CCMR_IC24PSC_Mask           ((u16)0xF3FF)
     68          #define CCMR_IC13F_Mask             ((u16)0xFF0F)
     69          #define CCMR_IC24F_Mask             ((u16)0x0FFF)
     70          
     71          #define CCER_CC1P_Mask              ((u16)0xFFFD)
     72          #define CCER_CC2P_Mask              ((u16)0xFFDF)
     73          #define CCER_CC3P_Mask              ((u16)0xFDFF)
     74          #define CCER_CC4P_Mask              ((u16)0xDFFF)
     75          
     76          #define CCER_CC1E_Set               ((u16)0x0001)
     77          #define CCER_CC1E_Reset             ((u16)0xFFFE)
     78          #define CCER_CC1E_Mask              ((u16)0xFFFE)
     79          
     80          #define CCER_CC2E_Set               ((u16)0x0010)
     81          #define CCER_CC2E_Reset             ((u16)0xFFEF)
     82          #define CCER_CC2E_Mask              ((u16)0xFFEF)
     83          
     84          #define CCER_CC3E_Set               ((u16)0x0100)
     85          #define CCER_CC3E_Reset             ((u16)0xFEFF)
     86          
     87          #define CCER_CC4E_Set               ((u16)0x1000)
     88          #define CCER_CC4E_Reset             ((u16)0xEFFF)
     89          #define CCER_CC4E_Mask              ((u16)0xEFFF)
     90          
     91          #define DCR_DMA_Mask                ((u16)0x0000)
     92          
     93          /* TIM private Masks */
     94          #define TIM_Period_Reset_Mask       ((u16)0x0000)
     95          #define TIM_Prescaler_Reset_Mask    ((u16)0x0000)
     96          #define TIM_Pulse_Reset_Mask        ((u16)0x0000)
     97          #define TIM_ICFilter_Mask           ((u8)0x00)
     98          
     99          /* Private macro -------------------------------------------------------------*/
    100          /* Private variables ---------------------------------------------------------*/
    101          static uc16 Tab_OCModeMask[4] = {0xFF00, 0x00FF, 0xFF00, 0x00FF};
    102          static uc16 Tab_PolarityMask[4] = {CCER_CC1P_Mask, CCER_CC2P_Mask, CCER_CC3P_Mask, CCER_CC4P_Mask};
    103          
    104          /* Private function prototypes -----------------------------------------------*/
    105          static void PWMI_Config(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct);
    106          static void TI1_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
    107                                 u8 TIM_ICFilter);
    108          static void TI2_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
    109                                 u8 TIM_ICFilter);
    110          static void TI3_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
    111                                 u8 TIM_ICFilter);
    112          static void TI4_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
    113                                 u8 TIM_ICFilter);
    114          /* Private functions ---------------------------------------------------------*/
    115          
    116          /*******************************************************************************
    117          * Function Name  : TIM_DeInit
    118          * Description    : Deinitializes the TIMx peripheral registers to their default
    119          *                  reset values.
    120          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    121          * Output         : None
    122          * Return         : None
    123          *******************************************************************************/
    124          void TIM_DeInit(TIM_TypeDef* TIMx)
    125          {  
    126            switch (*(u32*)&TIMx)
    127            {
    128              case TIM2_BASE:
    129                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
    130                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
    131                break;
    132           
    133              case TIM3_BASE:
    134                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
    135                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
    136                break;
    137           
    138              case TIM4_BASE:
    139                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
    140                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
    141                break;
    142           
    143              default:
    144                break;
    145            }
    146          }
    147          
    148          /*******************************************************************************
    149          * Function Name  : TIM_TimeBaseInit
    150          * Description    : Initializes the TIMx Time Base Unit peripheral according to 
    151          *                  the specified parameters in the TIM_TimeBaseInitStruct.
    152          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    153          *                  - TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef
    154          *                   structure that contains the configuration information for
    155          *                   the specified TIM peripheral.
    156          * Output         : None
    157          * Return         : None
    158          *******************************************************************************/
    159          void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
    160          {
    161            /* Check the parameters */
    162            assert(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
    163            assert(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
    164            
    165            /* Set the Autoreload value */
    166            TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
    167          
    168            /* Set the Prescaler value */
    169            TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
    170          
    171            /* Select the Counter Mode and set the clock division */
    172            TIMx->CR1 &= CR1_CKD_Mask & CR1_CounterMode_Mask;
    173            TIMx->CR1 |= (u32)TIM_TimeBaseInitStruct->TIM_ClockDivision |
    174                         TIM_TimeBaseInitStruct->TIM_CounterMode;
    175          }
    176          /*******************************************************************************
    177          * Function Name  : TIM_OCInit
    178          * Description    : Initializes the TIMx peripheral according to the specified
    179          *                  parameters in the TIM_OCInitStruct.
    180          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    181          *                  - TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
    182          *                    that contains the configuration information for the specified
    183          *                    TIM peripheral.
    184          * Output         : None
    185          * Return         : None
    186          *******************************************************************************/
    187          void TIM_OCInit(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    188          {
    189            u32 tmpccmrx = 0, tmpccer = 0;
    190            
    191            /* Check the parameters */
    192            assert(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    193            assert(IS_TIM_CHANNEL(TIM_OCInitStruct->TIM_Channel));
    194            assert(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));
    195          
    196            tmpccer = TIMx->CCER;
    197          
    198            if ((TIM_OCInitStruct->TIM_Channel == (u16)TIM_Channel_1) ||
    199                (TIM_OCInitStruct->TIM_Channel == (u16)TIM_Channel_2))
    200            {
    201              tmpccmrx = TIMx->CCMR1;
    202              
    203              /* Reset the Output Compare Bits */
    204              tmpccmrx &= Tab_OCModeMask[TIM_OCInitStruct->TIM_Channel];
    205          
    206              /* Set the Output Polarity level */
    207              tmpccer &= Tab_PolarityMask[TIM_OCInitStruct->TIM_Channel];
    208          
    209              if (TIM_OCInitStruct->TIM_Channel == TIM_Channel_1)
    210              {
    211                /* Disable the Channel 1: Reset the CCE Bit */
    212                TIMx->CCER &= CCER_CC1E_Reset;
    213          
    214                /* Select the Output Compare Mode */
    215                tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
    216          
    217                /* Set the Capture Compare Register value */
    218                TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
    219          
    220                /* Set the Capture Compare Enable Bit */
    221                if (TIM_OCInitStruct->TIM_OCMode != TIM_OCMode_Timing) // D.JIANG
    222                  tmpccer |= CCER_CC1E_Set;
    223          
    224                /* Set the Capture Compare Polarity */
    225                tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
    226              }
    227              else /* TIM_Channel_2 */
    228              {
    229                /* Disable the Channel 2: Reset the CCE Bit */
    230                TIMx->CCER &= CCER_CC2E_Reset;
    231          
    232                /* Select the Output Compare Mode */
    233                tmpccmrx |= (u32)TIM_OCInitStruct->TIM_OCMode << 8;
    234          
    235                /* Set the Capture Compare Register value */
    236                TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
    237          
    238                /* Set the Capture Compare Enable Bit */
    239                if (TIM_OCInitStruct->TIM_OCMode != TIM_OCMode_Timing) // D.JIANG
    240                  tmpccer |= CCER_CC2E_Set;
    241          
    242                /* Set the Capture Compare Polarity */
    243                tmpccer |= (u32)TIM_OCInitStruct->TIM_OCPolarity << 4;
    244              }
    245          
    246              TIMx->CCMR1 = (u16)tmpccmrx;
    247            }
    248            else 
    249            {
    250              if ((TIM_OCInitStruct->TIM_Channel == TIM_Channel_3) ||
    251                  (TIM_OCInitStruct->TIM_Channel == TIM_Channel_4))
    252              { 
    253                tmpccmrx = TIMx->CCMR2;
    254          
    255                /* Reset the Output Compare Bits */
    256                tmpccmrx &= Tab_OCModeMask[TIM_OCInitStruct->TIM_Channel];
    257          
    258                /* Set the Output Polarity level */
    259                tmpccer &= Tab_PolarityMask[TIM_OCInitStruct->TIM_Channel];
    260          
    261                if (TIM_OCInitStruct->TIM_Channel == TIM_Channel_3)
    262                {
    263                  /* Disable the Channel 3: Reset the CCE Bit */
    264                  TIMx->CCER &= CCER_CC3E_Reset;
    265          
    266                  /* Select the Output Compare Mode */
    267                  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
    268          
    269                  /* Set the Capture Compare Register value */
    270                  TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
    271          
    272                  /* Set the Capture Compare Enable Bit */
    273                  if (TIM_OCInitStruct->TIM_OCMode != TIM_OCMode_Timing) // D.JIANG
    274                    tmpccer |= CCER_CC3E_Set;
    275          
    276                  /* Set the Capture Compare Polarity */
    277                  tmpccer |= (u32)TIM_OCInitStruct->TIM_OCPolarity << 8;
    278                }
    279                else  /* TIM_Channel_4 */
    280                {
    281                  /* Disable the Channel 4: Reset the CCE Bit */
    282                  TIMx->CCER &= CCER_CC4E_Reset;
    283          
    284                 /* Select the Output Compare Mode */
    285                  tmpccmrx |= (u32)TIM_OCInitStruct->TIM_OCMode << 8;
    286          
    287                  /* Set the Capture Compare Register value */
    288                  TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
    289          
    290                  /* Set the Capture Compare Enable Bit */
    291                  if (TIM_OCInitStruct->TIM_OCMode != TIM_OCMode_Timing) // D.JIANG
    292                    tmpccer |= CCER_CC4E_Set;
    293          
    294                  /* Set the Capture Compare Polarity */
    295                  tmpccer |= (u32)TIM_OCInitStruct->TIM_OCPolarity << 12;
    296                }
    297          
    298                TIMx->CCMR2 = (u16)tmpccmrx;
    299              }
    300            }
    301            
    302            TIMx->CCER = (u16)tmpccer;
    303          }
    304          
    305          /*******************************************************************************
    306          * Function Name  : TIM_ICInit
    307          * Description    : Initializes the TIMx peripheral according to the specified
    308          *                  parameters in the TIM_ICInitStruct.
    309          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    310          *                  - TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
    311          *                    that contains the configuration information for the specified
    312          *                    TIM peripheral.
    313          * Output         : None
    314          * Return         : None
    315          *******************************************************************************/
    316          void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
    317          {
    318            /* Check the parameters */
    319            assert(IS_TIM_IC_MODE(TIM_ICInitStruct->TIM_ICMode));
    320            assert(IS_TIM_CHANNEL(TIM_ICInitStruct->TIM_Channel));
    321            assert(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
    322            assert(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
    323            assert(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
    324            assert(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
    325            
    326            if (TIM_ICInitStruct->TIM_ICMode == TIM_ICMode_ICAP)
    327            {
    328              if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
    329              {
    330                /* TI1 Configuration */
    331                TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
    332                           TIM_ICInitStruct->TIM_ICSelection,
    333                           TIM_ICInitStruct->TIM_ICFilter);
    334          
    335                /* Set the Input Capture Prescaler value */
    336                TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
    337              }
    338              else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
    339              {
    340                /* TI2 Configuration */
    341                TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
    342                           TIM_ICInitStruct->TIM_ICSelection,
    343                           TIM_ICInitStruct->TIM_ICFilter);
    344          
    345                /* Set the Input Capture Prescaler value */
    346                TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
    347              }
    348              else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
    349              {
    350                /* TI3 Configuration */
    351                TI3_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
    352                           TIM_ICInitStruct->TIM_ICSelection,
    353                           TIM_ICInitStruct->TIM_ICFilter);
    354          
    355                /* Set the Input Capture Prescaler value */
    356                TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
    357              }
    358              else /* TIM_Channel_4 */
    359              {
    360                /* TI4 Configuration */
    361                TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
    362                           TIM_ICInitStruct->TIM_ICSelection,
    363                           TIM_ICInitStruct->TIM_ICFilter);
    364          
    365                /* Set the Input Capture Prescaler value */
    366                TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
    367              }
    368            }
    369            else
    370            {
    371              PWMI_Config(TIMx, TIM_ICInitStruct);
    372            }
    373          }
    374          
    375          /*******************************************************************************
    376          * Function Name  : TIM_TimeBaseStructInit
    377          * Description    : Fills each TIM_TimeBaseInitStruct member with its default value.
    378          * Input          : - TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef
    379          *                    structure which will be initialized.
    380          * Output         : None
    381          * Return         : None
    382          *******************************************************************************/
    383          void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
    384          {
    385            /* Set the default configuration */
    386            TIM_TimeBaseInitStruct->TIM_Period = TIM_Period_Reset_Mask;
    387            TIM_TimeBaseInitStruct->TIM_Prescaler = TIM_Prescaler_Reset_Mask;
    388            TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
    389            TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
    390          }
    391          
    392          /*******************************************************************************
    393          * Function Name  : TIM_OCStructInit
    394          * Description    : Fills each TIM_OCInitStruct member with its default value.
    395          * Input          : - TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
    396          *                    which will be initialized.
    397          * Output         : None
    398          * Return         : None
    399          *******************************************************************************/
    400          void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
    401          {
    402            /* Set the default configuration */
    403            TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
    404            TIM_OCInitStruct->TIM_Channel = TIM_Channel_1;
    405            TIM_OCInitStruct->TIM_Pulse = TIM_Pulse_Reset_Mask;
    406            TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
    407          }
    408          
    409          /*******************************************************************************
    410          * Function Name  : TIM_ICStructInit
    411          * Description    : Fills each TIM_InitStruct member with its default value.
    412          * Input          : - TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
    413          *                    which will be initialized.
    414          * Output         : None
    415          * Return         : None
    416          *******************************************************************************/
    417          void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
    418          {
    419            /* Set the default configuration */
    420            TIM_ICInitStruct->TIM_ICMode = TIM_ICMode_ICAP;
    421            TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
    422            TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
    423            TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
    424            TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
    425            TIM_ICInitStruct->TIM_ICFilter = TIM_ICFilter_Mask;
    426          }
    427          
    428          /*******************************************************************************
    429          * Function Name  : TIM_Cmd
    430          * Description    : Enables or disables the specified TIM peripheral.
    431          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIMx peripheral.
    432          *                  - Newstate: new state of the TIMx peripheral.
    433          *                    This parameter can be: ENABLE or DISABLE.
    434          * Output         : None
    435          * Return         : None
    436          *******************************************************************************/
    437          void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
    438          {
    439            /* Check the parameters */
    440            assert(IS_FUNCTIONAL_STATE(NewState));
    441            
    442            if (NewState != DISABLE)
    443            {
    444              /* Enable the TIM Counter */
    445              TIMx->CR1 |= CR1_CEN_Set;
    446            }
    447            else
    448            {
    449              /* Disable the TIM Counter */
    450              TIMx->CR1 &= CR1_CEN_Reset;
    451            }
    452          }
    453          
    454          /*******************************************************************************
    455          * Function Name  : TIM_ITConfig
    456          * Description    : Enables or disables the TIMx interrupts.
    457          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    458          *                  - TIM_IT: specifies the TIM interrupts sources to be enabled
    459          *                    or disabled.
    460          *                    This parameter can be any combination of the following values:
    461          *                       - TIM_IT_Update: Timer update Interrupt
    462          *                       - TIM_IT_CC1: Capture Compare 1 Interrupt
    463          *                       - TIM_IT_CC2: Capture Compare 2 Interrupt
    464          *                       - TIM_IT_CC3: Capture Compare 3 Interrupt
    465          *                       - TIM_IT_CC4: Capture Compare 4 Interrupt
    466          *                       - TIM_IT_Trigger: Trigger Interrupt
    467          *                  - Newstate: new state of the specified TIMx interrupts.
    468          *                    This parameter can be: ENABLE or DISABLE.
    469          * Output         : None
    470          * Return         : None
    471          *******************************************************************************/
    472          void TIM_ITConfig(TIM_TypeDef* TIMx, u16 TIM_IT, FunctionalState NewState)
    473          {
    474            /* Check the parameters */
    475            assert(IS_TIM_IT(TIM_IT));
    476            assert(IS_FUNCTIONAL_STATE(NewState));
    477            
    478            if (NewState != DISABLE)
    479            {
    480              /* Enable the Interrupt sources */
    481              TIMx->DIER |= TIM_IT;
    482            }
    483            else
    484            {
    485              /* Disable the Interrupt sources */
    486              TIMx->DIER &= (u16)(~TIM_IT);
    487            }
    488          }
    489          
    490          /*******************************************************************************
    491          * Function Name  : TIM_DMAConfig
    492          * Description    : Configures the TIMx’s DMA interface.
    493          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    494          *                  - TIM_DMABase: DMA Base address.
    495          *                    This parameter can be one of the following values:
    496          *                       - TIM_DMABase_CR1, TIM_DMABase_CR2, TIM_DMABase_SMCR,
    497          *                         TIM_DMABase_DIER, TIM_DMABase_SR, TIM_DMABase_EGR,
    498          *                         TIM_DMABase_CCMR1, TIM_DMABase_CCMR2, TIM_DMABase_CCER,
    499          *                         TIM_DMABase_CNT, TIM_DMABase_PSC, TIM_DMABase_ARR,
    500          *                         TIM_DMABase_CCR1, TIM_DMABase_CCR2, TIM_DMABase_CCR3,
    501          *                         TIM_DMABase_CCR4, TIM_DMABase_DCR.
    502          *                  - TIM_DMABurstLength: DMA Burst length.
    503          *                    This parameter can be one value between:
    504          *                    TIM_DMABurstLength_1Byte and TIM_DMABurstLength_18Bytes.
    505          * Output         : None
    506          * Return         : None
    507          *******************************************************************************/
    508          void TIM_DMAConfig(TIM_TypeDef* TIMx, u16 TIM_DMABase, u16 TIM_DMABurstLength)
    509          {
    510            u32 tmpdcr = 0;
    511          
    512            /* Check the parameters */
    513            assert(IS_TIM_DMA_BASE(TIM_DMABase));
    514            assert(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
    515            
    516            tmpdcr = TIMx->DCR;
    517          
    518            /* Reset the DBA and the DBL Bits */
    519            tmpdcr &= DCR_DMA_Mask;
    520          
    521            /* Set the DMA Base and the DMA Burst Length */
    522            tmpdcr |= TIM_DMABase | TIM_DMABurstLength;
    523          
    524            TIMx->DCR = (u16)tmpdcr;
    525          }
    526          
    527          /*******************************************************************************
    528          * Function Name  : TIM_DMACmd
    529          * Description    : Enables or disables the TIMx’s DMA Requests.
    530          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    531          *                  - TIM_DMASources: specifies the DMA Request sources.
    532          *                    This parameter can be any combination of the following values:
    533          *                       - TIM_DMA_CC1: Capture Compare 1 DMA source
    534          *                       - TIM_DMA_CC2: Capture Compare 2 DMA source
    535          *                       - TIM_DMA_CC3: Capture Compare 3 DMA source
    536          *                       - TIM_DMA_CC4: Capture Compare 4 DMA source
    537          *                       - TIM_DMA_Trigger: Trigger DMA source
    538          *                  - Newstate: new state of the DMA Request sources.
    539          *                    This parameter can be: ENABLE or DISABLE.
    540          * Output         : None
    541          * Return         : None
    542          *******************************************************************************/
    543          void TIM_DMACmd(TIM_TypeDef* TIMx, u16 TIM_DMASource, FunctionalState Newstate)
    544          {
    545            u32 tmpdier = 0;
    546            
    547            /* Check the parameters */
    548            assert(IS_TIM_DMA_SOURCE(TIM_DMASource));
    549            assert(IS_FUNCTIONAL_STATE(Newstate));
    550          
    551            tmpdier = TIMx->DIER;
    552          
    553            if (Newstate != DISABLE)
    554            {
    555              /* Enable the DMA sources */
    556              tmpdier |= TIM_DMASource;
    557            }
    558            else
    559            {
    560              /* Disable the DMA sources */
    561              tmpdier &= (u16)(~TIM_DMASource);
    562            }
    563            TIMx->DIER = (u16)tmpdier;
    564          }
    565          
    566          /*******************************************************************************
    567          * Function Name  : TIM_InternalClockConfig
    568          * Description    : Configures the TIMx interrnal Clock
    569          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    570          * Output         : None
    571          * Return         : None
    572          *******************************************************************************/
    573          void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
    574          {
    575            /* Disable slave mode to clock the prescaler directly with the internal clock */
    576            TIMx->SMCR &=  SMCR_SMS_Mask;
    577          }
    578          /*******************************************************************************
    579          * Function Name  : TIM_ITRxExternalClockConfig
    580          * Description    : Configures the TIMx Internal Trigger as External Clock
    581          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    582          *                  - TIM_ITRSource: Trigger source.
    583          *                    This parameter can be one of the following values:
    584          *                       - TIM_TS_ITR0: Internal Trigger 0
    585          *                       - TIM_TS_ITR1: Internal Trigger 1
    586          *                       - TIM_TS_ITR2: Internal Trigger 2
    587          *                       - TIM_TS_ITR3: Internal Trigger 3
    588          * Output         : None
    589          * Return         : None
    590          *******************************************************************************/
    591          void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, u16 TIM_InputTriggerSource)
    592          {
    593            /* Check the parameters */
    594            assert(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
    595          
    596            /* Select the Internal Trigger */
    597            TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
    598          
    599            /* Select the External clock mode1 */
    600            TIMx->SMCR |= TIM_SlaveMode_External1;
    601          }
    602          /*******************************************************************************
    603          * Function Name  : TIM_TIxExternalClockConfig
    604          * Description    : Configures the TIMx Trigger as External Clock
    605          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    606          *                  - TIM_TIxExternalCLKSource: Trigger source.
    607          *                    This parameter can be one of the following values:
    608          *                       - TIM_TS_TI1F_ED: TI1 Edge Detector
    609          *                       - TIM_TS_TI1FP1: Filtered Timer Input 1
    610          *                       - TIM_TS_TI2FP2: Filtered Timer Input 2
    611          *                  - TIM_ICPolarity: specifies the TIx Polarity.
    612          *                    This parameter can be:
    613          *                       - TIM_ICPolarity_Rising
    614          *                       - TIM_ICPolarity_Falling
    615          *                   - ICFilter : specifies the filter value.
    616          *                     This parameter must be a value between 0x0 and 0xF.
    617          * Output         : None
    618          * Return         : None
    619          *******************************************************************************/
    620          void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, u16 TIM_TIxExternalCLKSource,
    621                                          u16 TIM_ICPolarity, u8 ICFilter)
    622          {
    623            /* Check the parameters */
    624            assert(IS_TIM_TIX_TRIGGER_SELECTION(TIM_TIxExternalCLKSource));
    625            assert(IS_TIM_IC_POLARITY(TIM_ICPolarity));
    626            assert(IS_TIM_IC_FILTER(ICFilter));
    627          
    628            /* Configure the Timer Input Clock Source */
    629            if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
    630            {
    631              TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
    632            }
    633            else
    634            {
    635              TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
    636            }
    637          
    638            /* Select the Trigger source */
    639            TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
    640          
    641            /* Select the External clock mode1 */
    642            TIMx->SMCR |= TIM_SlaveMode_External1;
    643          }
    644          
    645          /*******************************************************************************
    646          * Function Name  : TIM_ETRClockMode1Config
    647          * Description    : Configures the External clock Mode1
    648          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    649          *                  - TIM_ExtTRGPrescaler: The external Trigger Prescaler.
    650          *                    It can be one of the following values:
    651          *                       - TIM_ExtTRGPSC_OFF
    652          *                       - TIM_ExtTRGPSC_DIV2
    653          *                       - TIM_ExtTRGPSC_DIV4
    654          *                       - TIM_ExtTRGPSC_DIV8.
    655          *                  - TIM_ExtTRGPolarity: The external Trigger Polarity.
    656          *                    It can be one of the following values:
    657          *                       - TIM_ExtTRGPolarity_Inverted
    658          *                       - TIM_ExtTRGPolarity_NonInverted
    659          *                  - ExtTRGFilter: External Trigger Filter.
    660          *                    This parameter must be a value between 0x00 and 0x0F
    661          * Output         : None
    662          * Return         : None
    663          *******************************************************************************/
    664          void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, u16 TIM_ExtTRGPolarity,
    665                                       u8 ExtTRGFilter)
    666          {
    667            /* Check the parameters */
    668            assert(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
    669            assert(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
    670          
    671            /* Configure the ETR Clock source */
    672            TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
    673          
    674            /* Select the External clock mode1 */
    675            TIMx->SMCR &= SMCR_SMS_Mask;
    676            TIMx->SMCR |= TIM_SlaveMode_External1;
    677          
    678            /* Select the Trigger selection : ETRF */
    679            TIMx->SMCR &= SMCR_TS_Mask;
    680            TIMx->SMCR |= TIM_TS_ETRF;
    681          }
    682          
    683          /*******************************************************************************
    684          * Function Name  : TIM_ETRClockMode2Config
    685          * Description    : Configures the External clock Mode2
    686          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    687          *                  - TIM_ExtTRGPrescaler: The external Trigger Prescaler.
    688          *                    It can be one of the following values:
    689          *                       - TIM_ExtTRGPSC_OFF
    690          *                       - TIM_ExtTRGPSC_DIV2
    691          *                       - TIM_ExtTRGPSC_DIV4
    692          *                       - TIM_ExtTRGPSC_DIV8
    693          *                  - TIM_ExtTRGPolarity: The external Trigger Polarity.
    694          *                    It can be one of the following values:
    695          *                       - TIM_ExtTRGPolarity_Inverted
    696          *                       - TIM_ExtTRGPolarity_NonInverted
    697          *                  - ExtTRGFilter: External Trigger Filter.
    698          *                    This parameter must be a value between 0x00 and 0x0F
    699          * Output         : None
    700          * Return         : None
    701          *******************************************************************************/
    702          void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, 
    703                                       u16 TIM_ExtTRGPolarity, u8 ExtTRGFilter)
    704          {
    705            /* Check the parameters */
    706            assert(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
    707            assert(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
    708          
    709            /* Configure the ETR Clock source */
    710            TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
    711          
    712            /* Enable the External clock mode2 */
    713            TIMx->SMCR |= SMCR_ECE_Set;
    714          }
    715          
    716          /*******************************************************************************
    717          * Function Name  : TIM_ETRConfig
    718          * Description    : Configures the TIMx External Trigger (ETR).
    719          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    720          *                  - TIM_ExtTRGPrescaler: The external Trigger Prescaler.
    721          *                    This parameter can be one of the following values:
    722          *                       - TIM_ExtTRGPSC_OFF
    723          *                       - TIM_ExtTRGPSC_DIV2
    724          *                       - TIM_ExtTRGPSC_DIV4
    725          *                       - TIM_ExtTRGPSC_DIV8
    726          *                  - TIM_ExtTRGPolarity: The external Trigger Polarity.
    727          *                    This parameter can be one of the following values:
    728          *                       - TIM_ExtTRGPolarity_Inverted
    729          *                       - TIM_ExtTRGPolarity_NonInverted
    730          *                  - ExtTRGFilter: External Trigger Filter.
    731          *                    This parameter must be a value between 0x00 and 0x0F.
    732          * Output         : None
    733          * Return         : None
    734          *******************************************************************************/
    735           void TIM_ETRConfig(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, u16 TIM_ExtTRGPolarity,
    736                                 u8 ExtTRGFilter)
    737          {
    738            u32 tmpsmcr = 0;
    739          
    740            tmpsmcr = TIMx->SMCR;
    741          
    742            /* Set the Prescaler, the Filter value and the Polarity */
    743            tmpsmcr &= SMCR_ETR_Mask;
    744            tmpsmcr |= TIM_ExtTRGPrescaler | TIM_ExtTRGPolarity | (u16)((u16)ExtTRGFilter << 8);
    745          
    746            TIMx->SMCR = (u16)tmpsmcr;
    747          }
    748          
    749          /*******************************************************************************
    750          * Function Name  : TIM_SelectInputTrigger
    751          * Description    : Selects the Input Trigger source
    752          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    753          *                  - TIM_InputTriggerSource: The Input Trigger source.
    754          *                    This parameter can be one of the following values:
    755          *                       - TIM_TS_ITR0: Internal Trigger 0
    756          *                       - TIM_TS_ITR1: Internal Trigger 1
    757          *                       - TIM_TS_ITR2: Internal Trigger 2
    758          *                       - TIM_TS_ITR3: Internal Trigger 3
    759          *                       - TIM_TS_TI1F_ED: TI1 Edge Detector
    760          *                       - TIM_TS_TI1FP1: Filtered Timer Input 1
    761          *                       - TIM_TS_TI2FP2: Filtered Timer Input 2
    762          *                       - TIM_TS_ETRF: External Trigger input
    763          * Output         : None
    764          * Return         : None
    765          *******************************************************************************/
    766          void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, u16 TIM_InputTriggerSource)
    767          {
    768            u32 tmpsmcr = 0;
    769          
    770            /* Check the parameters */
    771            assert(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
    772          
    773            tmpsmcr = TIMx->SMCR;
    774          
    775            /* Select the Tgigger Source */
    776            tmpsmcr &= SMCR_TS_Mask;
    777            tmpsmcr |= TIM_InputTriggerSource;
    778          
    779            TIMx->SMCR = (u16)tmpsmcr;
    780          }
    781          
    782          /*******************************************************************************
    783          * Function Name  : TIM_PrescalerConfig
    784          * Description    : Configures the TIMx Prescaler.
    785          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    786          *                  - Prescaler: specifies the Prescaler Register value
    787          *                  - TIM_PSCReloadMode: specifies the TIM Prescaler Reload mode
    788          *                    This parameter can be one of the following values:
    789          *                       - TIM_PSCReloadMode_Update: The Prescaler is loaded at
    790          *                         the update event.
    791          *                       - TIM_PSCReloadMode_Immediate: The Prescaler is loaded
    792          *                         immediatly.
    793          * Output         : None
    794          * Return         : None
    795          *******************************************************************************/
    796          void TIM_PrescalerConfig(TIM_TypeDef* TIMx, u16 Prescaler, u16 TIM_PSCReloadMode)
    797          {
    798            /* Check the parameters */
    799            assert(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
    800          
    801            /* Set the Prescaler value */
    802            TIMx->PSC = Prescaler;
    803          
    804            /* Set or reset the UG Bit */
    805            if (TIM_PSCReloadMode == TIM_PSCReloadMode_Immediate)
    806            {
    807              TIMx->EGR |= TIM_EventSource_Update;
    808            }
    809            else
    810            {
    811              TIMx->EGR &= TIM_EventSource_Update;
    812            }
    813          }
    814          
    815          /*******************************************************************************
    816          * Function Name  : TIM_CounterModeConfig
    817          * Description    : Specifies the TIMx Counter Mode to be used.
    818          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    819          *                  - TIM_CounterMode: specifies the Counter Mode to be used
    820          *                    This parameter can be one of the following values:
    821          *                       - TIM_CounterMode_Up: TIM Up Counting Mode
    822          *                       - TIM_CounterMode_Down: TIM Down Counting Mode
    823          *                       - TIM_CounterMode_CenterAligned1: TIM Center Aligned Mode1
    824          *                       - TIM_CounterMode_CenterAligned2: TIM Center Aligned Mode2
    825          *                       - TIM_CounterMode_CenterAligned3: TIM Center Aligned Mode3
    826          * Output         : None
    827          * Return         : None
    828          *******************************************************************************/
    829          void TIM_CounterModeConfig(TIM_TypeDef* TIMx, u16 TIM_CounterMode)
    830          {
    831            u32 tmpcr1 = 0;
    832          
    833            /* Check the parameters */
    834            assert(IS_TIM_COUNTER_MODE(TIM_CounterMode));
    835          
    836            tmpcr1 = TIMx->CR1;
    837          
    838            /* Reset the CMS and DIR Bits */
    839            tmpcr1 &= CR1_CounterMode_Mask;
    840          
    841            /* Set the Counter Mode */
    842            tmpcr1 |= TIM_CounterMode;
    843          
    844            TIMx->CR1 = (u16)tmpcr1;
    845          }
    846          
    847          /*******************************************************************************
    848          * Function Name  : TIM_ForcedOC1Config
    849          * Description    : Forces the TIMx output 1 waveform to active or inactive level.
    850          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    851          *                  - TIM_ForcedAction: specifies the forced Action to be set to
    852          *                    the output waveform.
    853          *                    This parameter can be one of the following values:
    854          *                       - TIM_ForcedAction_Active: Force active level on OC1REF
    855          *                       - TIM_ForcedAction_InActive: Force inactive level on
    856          *                         OC1REF.
    857          * Output         : None
    858          * Return         : None
    859          *******************************************************************************/
    860          void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
    861          {
    862            u32 tmpccmr1 = 0;
    863          
    864            /* Check the parameters */
    865            assert(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
    866          
    867            tmpccmr1 = TIMx->CCMR1;
    868          
    869            /* Reset the OCM Bits */
    870            tmpccmr1 &= CCMR_OCM13_Mask;
    871          
    872            /* Configure The Forced output Mode */
    873            tmpccmr1 |= TIM_ForcedAction;
    874          
    875            TIMx->CCMR1 = (u16)tmpccmr1;
    876          }
    877          
    878          /*******************************************************************************
    879          * Function Name  : TIM_ForcedOC2Config
    880          * Description    : Forces the TIMx output 2 waveform to active or inactive level.
    881          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    882          *                  - TIM_ForcedAction: specifies the forced Action to be set to
    883          *                    the output waveform.
    884          *                    This parameter can be one of the following values:
    885          *                       - TIM_ForcedAction_Active: Force active level on OC2REF
    886          *                       - TIM_ForcedAction_InActive: Force inactive level on
    887          *                         OC2REF.
    888          * Output         : None
    889          * Return         : None
    890          *******************************************************************************/
    891          void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
    892          {
    893            u32 tmpccmr1 = 0;
    894          
    895            /* Check the parameters */
    896            assert(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
    897          
    898            tmpccmr1 = TIMx->CCMR1;
    899          
    900            /* Reset the OCM Bits */
    901            tmpccmr1 &= CCMR_OCM24_Mask;
    902          
    903            /* Configure The Forced output Mode */
    904            tmpccmr1 |= (u16)(TIM_ForcedAction << 8);
    905          
    906            TIMx->CCMR1 = (u16)tmpccmr1;
    907          }
    908          
    909          /*******************************************************************************
    910          * Function Name  : TIM_ForcedOC3Config
    911          * Description    : Forces the TIMx output 3 waveform to active or inactive level.
    912          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    913          *                  - TIM_ForcedAction: specifies the forced Action to be set to
    914          *                    the output waveform.
    915          *                    This parameter can be one of the following values:
    916          *                       - TIM_ForcedAction_Active: Force active level on OC3REF
    917          *                       - TIM_ForcedAction_InActive: Force inactive level on
    918          *                         OC3REF.
    919          * Output         : None
    920          * Return         : None
    921          *******************************************************************************/
    922          void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
    923          {
    924            u32 tmpccmr2 = 0;
    925          
    926            /* Check the parameters */
    927            assert(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
    928          
    929            tmpccmr2 = TIMx->CCMR2;
    930          
    931            /* Reset the OCM Bits */
    932            tmpccmr2 &= CCMR_OCM13_Mask;
    933          
    934            /* Configure The Forced output Mode */
    935            tmpccmr2 |= TIM_ForcedAction;
    936          
    937            TIMx->CCMR2 = (u16)tmpccmr2;
    938          }
    939          
    940          /*******************************************************************************
    941          * Function Name  : TIM_ForcedOC4Config
    942          * Description    : Forces the TIMx output 4 waveform to active or inactive level.
    943          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    944          *                  - TIM_ForcedAction: specifies the forced Action to be set to
    945          *                    the output waveform.
    946          *                    This parameter can be one of the following values:
    947          *                       - TIM_ForcedAction_Active: Force active level on OC4REF
    948          *                       - TIM_ForcedAction_InActive: Force inactive level on
    949          *                         OC4REF.
    950          * Output         : None
    951          * Return         : None
    952          *******************************************************************************/
    953          void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
    954          {
    955            u32 tmpccmr2 = 0;
    956          
    957            /* Check the parameters */
    958            assert(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
    959          
    960            tmpccmr2 = TIMx->CCMR2;
    961          
    962            /* Reset the OCM Bits */
    963            tmpccmr2 &= CCMR_OCM24_Mask;
    964          
    965            /* Configure The Forced output Mode */
    966            tmpccmr2 |= (u16)(TIM_ForcedAction << 8);
    967          
    968            TIMx->CCMR2 = (u16)tmpccmr2;
    969          }
    970          
    971          /*******************************************************************************
    972          * Function Name  : TIM_ARRPreloadConfig
    973          * Description    : Enables or disables TIMx peripheral Preload register on ARR.
    974          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    975          *                  - Newstate: new state of the TIMx peripheral Preload register
    976          *                    This parameter can be: ENABLE or DISABLE.
    977          * Output         : None
    978          * Return         : None
    979          *******************************************************************************/
    980          void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState Newstate)
    981          {
    982            u32 tmpcr1 = 0;
    983            
    984            /* Check the parameters */
    985            assert(IS_FUNCTIONAL_STATE(Newstate));
    986          
    987            tmpcr1 = TIMx->CR1;
    988          
    989            if (Newstate != DISABLE)
    990            {
    991              /* Set the ARR Preload Bit */
    992              tmpcr1 |= CR1_ARPE_Set;
    993            }
    994            else
    995            {
    996              /* Reset the ARR Preload Bit */
    997              tmpcr1 &= CR1_ARPE_Reset;
    998            }
    999          
   1000            TIMx->CR1 = (u16)tmpcr1;
   1001          }
   1002          
   1003          /*******************************************************************************
   1004          * Function Name  : TIM_SelectCCDMA
   1005          * Description    : Selects the TIMx peripheral Capture Compare DMA source.
   1006          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1007          *                  - Newstate: new state of the Capture Compare DMA source
   1008          *                    This parameter can be: ENABLE or DISABLE.
   1009          * Output         : None
   1010          * Return         : None
   1011          *******************************************************************************/
   1012          void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState Newstate)
   1013          {
   1014            u32 tmpcr2 = 0;
   1015          
   1016            /* Check the parameters */
   1017            assert(IS_FUNCTIONAL_STATE(Newstate));
   1018          
   1019            tmpcr2 = TIMx->CR2;
   1020          
   1021            if (Newstate != DISABLE)
   1022            {
   1023              /* Set the CCDS Bit */
   1024              tmpcr2 |= CR2_CCDS_Set;
   1025            }
   1026            else
   1027            {
   1028              /* Reset the CCDS Bit */
   1029              tmpcr2 &= CR2_CCDS_Reset;
   1030            }
   1031          
   1032            TIMx->CR2 = (u16)tmpcr2;
   1033          }
   1034          
   1035          /*******************************************************************************
   1036          * Function Name  : TIM_OC1PreloadConfig
   1037          * Description    : Enables or disables the TIMx peripheral Preload register on CCR1.
   1038          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1039          *                  - TIM_OCPreload: new state of the TIMx peripheral Preload
   1040          *                    register
   1041          *                    This parameter can be one of the following values:
   1042          *                       - TIM_OCPreload_Enable
   1043          *                       - TIM_OCPreload_Disable
   1044          * Output         : None
   1045          * Return         : None
   1046          *******************************************************************************/
   1047          void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
   1048          {
   1049            u32 tmpccmr1 = 0;
   1050          
   1051            /* Check the parameters */
   1052            assert(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1053          
   1054            tmpccmr1 = TIMx->CCMR1;
   1055          
   1056            /* Reset the OCPE Bit */
   1057            tmpccmr1 &= CCMR_OC13PE_Mask;
   1058          
   1059            /* Enable or Disable the Output Compare Preload feature */
   1060            tmpccmr1 |= TIM_OCPreload;
   1061          
   1062            TIMx->CCMR1 = (u16)tmpccmr1;
   1063          }
   1064          
   1065          /*******************************************************************************
   1066          * Function Name  : TIM_OC2PreloadConfig
   1067          * Description    : Enables or disables the TIMx peripheral Preload register on CCR2.
   1068          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1069          *                  - TIM_OCPreload: new state of the TIMx peripheral Preload
   1070          *                    register
   1071          *                    This parameter can be one of the following values:
   1072          *                       - TIM_OCPreload_Enable
   1073          *                       - TIM_OCPreload_Disable
   1074          * Output         : None
   1075          * Return         : None
   1076          *******************************************************************************/
   1077          void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
   1078          {
   1079            u32 tmpccmr1 = 0;
   1080          
   1081            /* Check the parameters */
   1082            assert(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1083          
   1084            tmpccmr1 = TIMx->CCMR1;
   1085          
   1086            /* Reset the OCPE Bit */
   1087            tmpccmr1 &= CCMR_OC24PE_Mask;
   1088          
   1089            /* Enable or Disable the Output Compare Preload feature */
   1090            tmpccmr1 |= (u16)(TIM_OCPreload << 8);
   1091          
   1092            TIMx->CCMR1 = (u16)tmpccmr1;
   1093          }
   1094          
   1095          /*******************************************************************************
   1096          * Function Name  : TIM_OC3PreloadConfig
   1097          * Description    : Enables or disables the TIMx peripheral Preload register on CCR3.
   1098          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1099          *                  - TIM_OCPreload: new state of the TIMx peripheral Preload
   1100          *                    register
   1101          *                    This parameter can be one of the following values:
   1102          *                       - TIM_OCPreload_Enable
   1103          *                       - TIM_OCPreload_Disable
   1104          * Output         : None
   1105          * Return         : None
   1106          *******************************************************************************/
   1107          void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
   1108          {
   1109            u32 tmpccmr2 = 0;
   1110          
   1111            /* Check the parameters */
   1112            assert(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1113          
   1114            tmpccmr2 = TIMx->CCMR2;
   1115          
   1116            /* Reset the OCPE Bit */
   1117            tmpccmr2 &= CCMR_OC13PE_Mask;
   1118          
   1119            /* Enable or Disable the Output Compare Preload feature */
   1120            tmpccmr2 |= TIM_OCPreload;
   1121          
   1122            TIMx->CCMR2 = (u16)tmpccmr2;
   1123          }
   1124          
   1125          /*******************************************************************************
   1126          * Function Name  : TIM_OC4PreloadConfig
   1127          * Description    : Enables or disables the TIMx peripheral Preload register on CCR4.
   1128          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1129          *                  - TIM_OCPreload: new state of the TIMx peripheral Preload
   1130          *                    register
   1131          *                    This parameter can be one of the following values:
   1132          *                       - TIM_OCPreload_Enable
   1133          *                       - TIM_OCPreload_Disable
   1134          * Output         : None
   1135          * Return         : None
   1136          *******************************************************************************/
   1137          void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
   1138          {
   1139            u32 tmpccmr2 = 0;
   1140          
   1141            /* Check the parameters */
   1142            assert(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1143          
   1144            tmpccmr2 = TIMx->CCMR2;
   1145          
   1146            /* Reset the OCPE Bit */
   1147            tmpccmr2 &= CCMR_OC24PE_Mask;
   1148          
   1149            /* Enable or Disable the Output Compare Preload feature */
   1150            tmpccmr2 |= (u16)(TIM_OCPreload << 8);
   1151          
   1152            TIMx->CCMR2 = (u16)tmpccmr2;
   1153          }
   1154          
   1155          /*******************************************************************************
   1156          * Function Name  : TIM_OC1FastConfig
   1157          * Description    : Configures the TIMx Output Compare 1 Fast feature.
   1158          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1159          *                  - TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1160          *                    This parameter can be one of the following values:
   1161          *                       - TIM_OCFast_Enable
   1162          *                       - TIM_OCFast_Disable
   1163          * Output         : None
   1164          * Return         : None
   1165          *******************************************************************************/
   1166          void TIM_OC1FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
   1167          {
   1168            u32 tmpccmr1 = 0;
   1169          
   1170            /* Check the parameters */
   1171            assert(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1172          
   1173            tmpccmr1 = TIMx->CCMR1;
   1174          
   1175            /* Reset the OCFE Bit */
   1176            tmpccmr1 &= CCMR_OC13FE_Mask;
   1177          
   1178            /* Enable or Disable the Output Compare Fast Bit */
   1179            tmpccmr1 |= TIM_OCFast;
   1180          
   1181            TIMx->CCMR1 = (u16)tmpccmr1;
   1182          }
   1183          
   1184          /*******************************************************************************
   1185          * Function Name  : TIM_OC2FastConfig
   1186          * Description    : Configures the TIMx Output Compare 2 Fast feature.
   1187          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1188          *                  - TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1189          *                    This parameter can be one of the following values:
   1190          *                       - TIM_OCFast_Enable
   1191          *                       - TIM_OCFast_Disable
   1192          * Output         : None
   1193          * Return         : None
   1194          *******************************************************************************/
   1195          void TIM_OC2FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
   1196          {
   1197            u32 tmpccmr1 = 0;
   1198          
   1199            /* Check the parameters */
   1200            assert(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1201          
   1202            tmpccmr1 = TIMx->CCMR1;
   1203          
   1204            /* Reset the OCFE Bit */
   1205            tmpccmr1 &= CCMR_OC24FE_Mask;
   1206          
   1207            /* Enable or Disable the Output Compare Fast Bit */
   1208            tmpccmr1 |= (u16)(TIM_OCFast << 8);
   1209          
   1210            TIMx->CCMR1 = (u16)tmpccmr1;
   1211          }
   1212          
   1213          /*******************************************************************************
   1214          * Function Name  : TIM_OC3FastConfig
   1215          * Description    : Configures the TIMx Output Compare 3 Fast feature.
   1216          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1217          *                  - TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1218          *                    This parameter can be one of the following values:
   1219          *                       - TIM_OCFast_Enable
   1220          *                       - TIM_OCFast_Disable
   1221          * Output         : None
   1222          * Return         : None
   1223          *******************************************************************************/
   1224          void TIM_OC3FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
   1225          {
   1226            u32 tmpccmr2 = 0;
   1227          
   1228            /* Check the parameters */
   1229            assert(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1230          
   1231            tmpccmr2 = TIMx->CCMR2;
   1232          
   1233            /* Reset the OCFE Bit */
   1234            tmpccmr2 &= CCMR_OC13FE_Mask;
   1235          
   1236            /* Enable or Disable the Output Compare Fast Bit */
   1237            tmpccmr2 |= TIM_OCFast;
   1238          
   1239            TIMx->CCMR2 = (u16)tmpccmr2;
   1240          }
   1241          
   1242          /*******************************************************************************
   1243          * Function Name  : TIM_OC4FastConfig
   1244          * Description    : Configures the TIMx Output Compare 4 Fast feature.
   1245          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1246          *                  - TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1247          *                    This parameter can be one of the following values:
   1248          *                       - TIM_OCFast_Enable
   1249          *                       - TIM_OCFast_Disable
   1250          * Output         : None
   1251          * Return         : None
   1252          *******************************************************************************/
   1253          void TIM_OC4FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
   1254          {
   1255            u32 tmpccmr2 = 0;
   1256          
   1257            /* Check the parameters */
   1258            assert(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1259          
   1260            tmpccmr2 = TIMx->CCMR2;
   1261          
   1262            /* Reset the OCFE Bit */
   1263            tmpccmr2 &= CCMR_OC24FE_Mask;
   1264          
   1265            /* Enable or Disable the Output Compare Fast Bit */
   1266            tmpccmr2 |= (u16)(TIM_OCFast << 8);
   1267          
   1268            TIMx->CCMR2 = (u16)tmpccmr2;
   1269          }
   1270          
   1271          /*******************************************************************************
   1272          * Function Name  : TIM_ClearOC1Ref
   1273          * Description    : Clears or safeguards the OCREF1 signal on an external event
   1274          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1275          *                  - TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1276          *                    This parameter can be one of the following values:
   1277          *                       - TIM_OCClear_Enable
   1278          *                       - TIM_OCClear_Disable
   1279          * Output         : None
   1280          * Return         : None
   1281          *******************************************************************************/
   1282          void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
   1283          {
   1284            u32 tmpccmr1 = 0;
   1285          
   1286            /* Check the parameters */
   1287            assert(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1288          
   1289            tmpccmr1 = TIMx->CCMR1;
   1290          
   1291            /* Reset the OCFE Bit */
   1292            tmpccmr1 &= CCMR_OC13CE_Mask;
   1293          
   1294            /* Enable or Disable the Output Compare Clear Bit */
   1295            tmpccmr1 |= (u16)(TIM_OCClear);
   1296          
   1297            TIMx->CCMR1 = (u16)tmpccmr1;
   1298          }
   1299          
   1300          /*******************************************************************************
   1301          * Function Name  : TIM_ClearOC2Ref
   1302          * Description    : Clears or safeguards the OCREF2 signal on an external event
   1303          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1304          *                  - TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1305          *                    This parameter can be one of the following values:
   1306          *                       - TIM_OCClear_Enable
   1307          *                       - TIM_OCClear_Disable
   1308          * Output         : None
   1309          * Return         : None
   1310          *******************************************************************************/
   1311          void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
   1312          {
   1313            u32 tmpccmr1 = 0;
   1314          
   1315            /* Check the parameters */
   1316            assert(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1317          
   1318            tmpccmr1 = TIMx->CCMR1;
   1319          
   1320            /* Reset the OCFE Bit */
   1321            tmpccmr1 &= CCMR_OC24CE_Mask;
   1322          
   1323            /* Enable or Disable the Output Compare Clear Bit */
   1324            tmpccmr1 |= (u16)(TIM_OCClear << 8);
   1325          
   1326            TIMx->CCMR1 = (u16)tmpccmr1;
   1327          }
   1328          
   1329          /*******************************************************************************
   1330          * Function Name  : TIM_ClearOC3Ref
   1331          * Description    : Clears or safeguards the OCREF3 signal on an external event
   1332          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1333          *                  - TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1334          *                    This parameter can be one of the following values:
   1335          *                       - TIM_OCClear_Enable
   1336          *                       - TIM_OCClear_Disable
   1337          * Output         : None
   1338          * Return         : None
   1339          *******************************************************************************/
   1340          void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
   1341          {
   1342            u32 tmpccmr2 = 0;
   1343          
   1344            /* Check the parameters */
   1345            assert(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1346          
   1347            tmpccmr2 = TIMx->CCMR2;
   1348          
   1349            /* Reset the OCFE Bit */
   1350            tmpccmr2 &= CCMR_OC13CE_Mask;
   1351          
   1352            /* Enable or Disable the Output Compare Clear Bit */
   1353            tmpccmr2 |= (u16)(TIM_OCClear);
   1354          
   1355            TIMx->CCMR2 = (u16)tmpccmr2;
   1356          }
   1357          
   1358          /*******************************************************************************
   1359          * Function Name  : TIM_ClearOC4Ref
   1360          * Description    : Clears or safeguards the OCREF4 signal on an external event
   1361          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1362          *                  - TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1363          *                    This parameter can be one of the following values:
   1364          *                       - TIM_OCClear_Enable
   1365          *                       - TIM_OCClear_Disable
   1366          * Output         : None
   1367          * Return         : None
   1368          *******************************************************************************/
   1369          void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
   1370          {
   1371            u32 tmpccmr2 = 0;
   1372          
   1373            /* Check the parameters */
   1374            assert(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1375          
   1376            tmpccmr2 = TIMx->CCMR2;
   1377          
   1378            /* Reset the OCFE Bit */
   1379            tmpccmr2 &= CCMR_OC24CE_Mask;
   1380          
   1381            /* Enable or Disable the Output Compare Clear Bit */
   1382            tmpccmr2 |= (u16)(TIM_OCClear << 8);
   1383          
   1384            TIMx->CCMR2 = (u16)tmpccmr2;
   1385          }
   1386          
   1387          /*******************************************************************************
   1388          * Function Name  : TIM_UpdateDisableConfig
   1389          * Description    : Enables or Disables the TIMx Update event.
   1390          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1391          *                  - Newstate: new state of the TIMx peripheral Preload register
   1392          *                    This parameter can be: ENABLE or DISABLE.
   1393          * Output         : None
   1394          * Return         : None
   1395          *******************************************************************************/
   1396          void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState Newstate)
   1397          {
   1398            u32 tmpcr1 = 0;
   1399          
   1400            /* Check the parameters */
   1401            assert(IS_FUNCTIONAL_STATE(Newstate));
   1402          
   1403            tmpcr1 = TIMx->CR1;
   1404          
   1405            if (Newstate != DISABLE)
   1406            {
   1407              /* Set the Update Disable Bit */
   1408              tmpcr1 |= CR1_UDIS_Set;
   1409            }
   1410            else
   1411            {
   1412              /* Reset the Update Disable Bit */
   1413              tmpcr1 &= CR1_UDIS_Reset;
   1414            }
   1415          
   1416            TIMx->CR1 = (u16)tmpcr1;
   1417          }
   1418          
   1419          /*******************************************************************************
   1420          * Function Name  : TIM_EncoderInterfaceConfig
   1421          * Description    : Configures the TIMx Encoder Interface.
   1422          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1423          *                  - TIM_EncoderMode: specifies the TIMx Encoder Mode.
   1424          *                    This parameter can be one of the following values:
   1425          *                       - TIM_EncoderMode_TI1: Counter counts on TI1FP1 edge
   1426          *                         depending on TI2FP2 level.
   1427          *                       - TIM_EncoderMode_TI2: Counter counts on TI2FP2 edge
   1428          *                         depending on TI1FP1 level.
   1429          *                       - TIM_EncoderMode_TI12: Counter counts on both TI1FP1 and
   1430          *                         TI2FP2 edges depending on the level of the other input.
   1431          *                  - TIM_IC1Polarity: specifies the IC1 Polarity
   1432          *                    This parmeter can be one of the following values:
   1433          *                        - TIM_ICPolarity_Falling
   1434          *                        - TIM_ICPolarity_Rising
   1435          *                  - TIM_IC2Polarity: specifies the IC2 Polarity
   1436          *                    This parmeter can be one of the following values:
   1437          *                       - TIM_ICPolarity_Falling
   1438          *                       - TIM_ICPolarity_Rising
   1439          * Output         : None
   1440          * Return         : None
   1441          *******************************************************************************/
   1442          void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, u16 TIM_EncoderMode,
   1443                                          u16 TIM_IC1Polarity, u16 TIM_IC2Polarity)
   1444          {
   1445            u32 tmpsmcr = 0;
   1446            u32 tmpccmr1 = 0;
   1447            u32 tmpccer = 0;
   1448              
   1449            /* Check the parameters */
   1450            assert(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
   1451            assert(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
   1452            assert(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
   1453          
   1454            tmpsmcr = TIMx->SMCR;
   1455            tmpccmr1 = TIMx->CCMR1;
   1456            tmpccer = TIMx->CCER;
   1457          
   1458            /* Set the encoder Mode */
   1459            tmpsmcr &= SMCR_SMS_Mask;
   1460            tmpsmcr |= TIM_EncoderMode;
   1461          
   1462            /* Select the Capture Compare 1 and the Capture Compare 2 as input */
   1463            tmpccmr1 &= CCMR_CC13S_Mask & CCMR_CC24S_Mask;
   1464            tmpccmr1 |= CCMR_TI13Direct_Set | CCMR_TI24Direct_Set;
   1465          
   1466            /* Set the TI1 and the TI2 Polarities */
   1467            tmpccer &= CCER_CC1P_Mask & CCER_CC2P_Mask;
   1468            tmpccer |= (TIM_IC1Polarity | (u16)((u16)TIM_IC2Polarity << 4));
   1469          
   1470            TIMx->SMCR = (u16)tmpsmcr;
   1471          
   1472            TIMx->CCMR1 = (u16)tmpccmr1;
   1473          
   1474            TIMx->CCER = (u16)tmpccer;
   1475          }
   1476          
   1477          /*******************************************************************************
   1478          * Function Name  : TIM_GenerateEvent
   1479          * Description    : Configures the TIMx event to be generate by software.
   1480          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1481          *                  - TIM_EventSource: specifies the event source.
   1482          *                    This parameter can be one or more of the following values:
   1483          *                       - TIM_EventSource_Update: Timer update Event source
   1484          *                       - TIM_EventSource_CC1: Timer Capture Compare 1 Event source
   1485          *                       - TIM_EventSource_CC2: Timer Capture Compare 2 Event source
   1486          *                       - TIM_EventSource_CC3: Timer Capture Compare 3 Event source
   1487          *                       - TIM_EventSource_CC4: Timer Capture Compare 4 Event source
   1488          *                       - TIM_EventSource_Trigger: Timer Trigger Event source
   1489          * Output         : None
   1490          * Return         : None
   1491          *******************************************************************************/
   1492          void TIM_GenerateEvent(TIM_TypeDef* TIMx, u16 TIM_EventSource)
   1493          {
   1494            /* Check the parameters */
   1495            assert(IS_TIM_EVENT_SOURCE(TIM_EventSource));
   1496          
   1497            /* Set the event sources */
   1498            TIMx->EGR |= TIM_EventSource;
   1499          }
   1500          
   1501          /*******************************************************************************
   1502          * Function Name  : TIM_OC1PolarityConfig
   1503          * Description    : Configures the TIMx channel 1 polarity.
   1504          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1505          *                  - TIM_OCPolarity: specifies the OC1 Polarity
   1506          *                    This parmeter can be one of the following values:
   1507          *                       - TIM_OCPolarity_High: Output Compare active high
   1508          *                       - TIM_OCPolarity_Low: Output Compare active low
   1509          * Output         : None
   1510          * Return         : None
   1511          *******************************************************************************/
   1512          void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
   1513          {
   1514            u32 tmpccer = 0;
   1515          
   1516            /* Check the parameters */
   1517            assert(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1518          
   1519            tmpccer = TIMx->CCER;
   1520          
   1521            /* Set or Reset the CC1P Bit */
   1522            tmpccer &= CCER_CC1P_Mask;
   1523            tmpccer |= TIM_OCPolarity;
   1524          
   1525            TIMx->CCER = (u16)tmpccer;
   1526          }
   1527          
   1528          /*******************************************************************************
   1529          * Function Name  : TIM_OC2PolarityConfig
   1530          * Description    : Configures the TIMx channel 2 polarity.
   1531          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1532          *                  - TIM_OCPolarity: specifies the OC2 Polarity
   1533          *                    This parmeter can be one of the following values:
   1534          *                       - TIM_OCPolarity_High: Output Compare active high
   1535          *                       - TIM_OCPolarity_Low: Output Compare active low
   1536          * Output         : None
   1537          * Return         : None
   1538          *******************************************************************************/
   1539          void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
   1540          {
   1541            u32 tmpccer = 0;
   1542          
   1543            /* Check the parameters */
   1544            assert(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1545          
   1546            tmpccer = TIMx->CCER;
   1547          
   1548            /* Set or Reset the CC2P Bit */
   1549            tmpccer &= CCER_CC2P_Mask;
   1550            tmpccer |= (u16)((u16)TIM_OCPolarity << 4);
   1551          
   1552            TIMx->CCER = (u16)tmpccer;
   1553          }
   1554          
   1555          /*******************************************************************************
   1556          * Function Name  : TIM_OC3PolarityConfig
   1557          * Description    : Configures the TIMx channel 3 polarity.
   1558          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1559          *                  - TIM_OCPolarity: specifies the OC3 Polarity
   1560          *                    This parmeter can be one of the following values:
   1561          *                       - TIM_OCPolarity_High: Output Compare active high
   1562          *                       - TIM_OCPolarity_Low: Output Compare active low
   1563          * Output         : None
   1564          * Return         : None
   1565          *******************************************************************************/
   1566          void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
   1567          {
   1568            u32 tmpccer = 0;
   1569          
   1570            /* Check the parameters */
   1571            assert(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1572          
   1573            tmpccer = TIMx->CCER;
   1574          
   1575            /* Set or Reset the CC3P Bit */
   1576            tmpccer &= CCER_CC3P_Mask;
   1577            tmpccer |= (u16)((u16)TIM_OCPolarity << 8);
   1578          
   1579            TIMx->CCER = (u16)tmpccer;
   1580          }
   1581          
   1582          /*******************************************************************************
   1583          * Function Name  : TIM_OC4PolarityConfig
   1584          * Description    : Configures the TIMx channel 4 polarity.
   1585          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1586          *                  - TIM_OCPolarity: specifies the OC4 Polarity
   1587          *                    This parmeter can be one of the following values:
   1588          *                       - TIM_OCPolarity_High: Output Compare active high
   1589          *                       - TIM_OCPolarity_Low: Output Compare active low
   1590          * Output         : None
   1591          * Return         : None
   1592          *******************************************************************************/
   1593          void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
   1594          {
   1595            u32 tmpccer = 0;
   1596          
   1597            /* Check the parameters */
   1598            assert(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1599          
   1600            tmpccer = TIMx->CCER;
   1601          
   1602            /* Set or Reset the CC4P Bit */
   1603            tmpccer &= CCER_CC4P_Mask;
   1604            tmpccer |= (u16)((u16)TIM_OCPolarity << 12);
   1605          
   1606            TIMx->CCER = (u16)tmpccer;
   1607          }
   1608          
   1609          /*******************************************************************************
   1610          * Function Name  : TIM_UpdateRequestConfig
   1611          * Description    : Configures the TIMx Update Request Interrupt source.
   1612          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1613          *                  - TIM_UpdateSource: specifies the Update source.
   1614          *                    This parameter can be one of the following values:
   1615          *                       - TIM_UpdateSource_Regular
   1616          *                       - TIM_UpdateSource_Global
   1617          * Output         : None
   1618          * Return         : None
   1619          *******************************************************************************/
   1620          void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, u16 TIM_UpdateSource)
   1621          {
   1622            u32 tmpcr1 = 0;
   1623          
   1624            /* Check the parameters */
   1625            assert(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
   1626          
   1627            tmpcr1 = TIMx->CR1;
   1628          
   1629            if (TIM_UpdateSource == TIM_UpdateSource_Regular)
   1630            {
   1631              /* Set the URS Bit */
   1632              tmpcr1 |= CR1_URS_Set;
   1633            }
   1634            else
   1635            {
   1636              /* Reset the URS Bit */
   1637              tmpcr1 &= CR1_URS_Reset;
   1638            }
   1639            TIMx->CR1 = (u16)tmpcr1;
   1640          }
   1641          
   1642          /*******************************************************************************
   1643          * Function Name  : TIM_SelectHallSensor
   1644          * Description    : Enables or disables the TIMx’s Hall sensor interface.
   1645          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1646          *                  - Newstate: new state of the TIMx Hall sensor interface.
   1647          *                    This parameter can be: ENABLE or DISABLE.
   1648          * Output         : None
   1649          * Return         : None
   1650          *******************************************************************************/
   1651          void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState Newstate)
   1652          {
   1653            /* Check the parameters */
   1654            assert(IS_FUNCTIONAL_STATE(Newstate));
   1655          
   1656            if (Newstate != DISABLE)
   1657            {
   1658              /* Set the TI1S Bit */
   1659              TIMx->CR2 |= CR2_TI1S_Set;
   1660            }
   1661            else
   1662            {
   1663              /* Reset the TI1S Bit */
   1664              TIMx->CR2 &= CR2_TI1S_Reset;
   1665            }
   1666          }
   1667          
   1668          /*******************************************************************************
   1669          * Function Name  : TIM_SelectOnePulseMode
   1670          * Description    : Selects the TIMx’s One Pulse Mode.
   1671          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1672          *                  - TIM_OPMode: specifies the OPM Mode to be used.
   1673          *                    This parameter can be one of the following values:
   1674          *                       - TIM_OPMode_Single
   1675          *                       - TIM_OPMode_Repetitive
   1676          * Output         : None
   1677          * Return         : None
   1678          *******************************************************************************/
   1679          void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, u16 TIM_OPMode)
   1680          {
   1681            u32 tmpcr1 = 0;
   1682          
   1683            /* Check the parameters */
   1684            assert(IS_TIM_OPM_MODE(TIM_OPMode));
   1685          
   1686            tmpcr1 = TIMx->CR1;
   1687          
   1688            /* Reset the OPM Bit */
   1689            tmpcr1 &= CR1_OPM_Mask;
   1690          
   1691            /* Configure the OPM Mode */
   1692            tmpcr1 |= TIM_OPMode;
   1693          
   1694            TIMx->CR1 = (u16)tmpcr1;
   1695          }
   1696          
   1697          /*******************************************************************************
   1698          * Function Name  : TIM_SelectOutputTrigger
   1699          * Description    : Selects the TIMx Trigger Output Mode.
   1700          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1701          *                  - TIM_TRGOSource: specifies the Trigger Output source.
   1702          *                    This paramter can be one of the following values:
   1703          *                       - TIM_TRGOSource_Reset
   1704          *                       - TIM_TRGOSource_Enable
   1705          *                       - TIM_TRGOSource_Update
   1706          *                       - TIM_TRGOSource_OC1
   1707          *                       - TIM_TRGOSource_OC1Ref
   1708          *                       - TIM_TRGOSource_OC2Ref
   1709          *                       - TIM_TRGOSource_OC3Ref
   1710          *                       - TIM_TRGOSource_OC4Ref
   1711          * Output         : None
   1712          * Return         : None
   1713          *******************************************************************************/
   1714          void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, u16 TIM_TRGOSource)
   1715          {
   1716            u32 tmpcr2 = 0;
   1717          
   1718            /* Check the parameters */
   1719            assert(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
   1720          
   1721            tmpcr2 = TIMx->CR2;
   1722            /* Reset the MMS Bits */
   1723            tmpcr2 &= CR2_MMS_Mask;
   1724          
   1725            /* Select the TRGO source */
   1726            tmpcr2 |=  TIM_TRGOSource;
   1727          
   1728            TIMx->CR2 = (u16)tmpcr2;
   1729          }
   1730          
   1731          /*******************************************************************************
   1732          * Function Name  : TIM_SelectSlaveMode
   1733          * Description    : Selects the TIMx Slave Mode.
   1734          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1735          *                  - TIM_SlaveMode: specifies the Timer Slave Mode.
   1736          *                    This paramter can be one of the following values:
   1737          *                       - TIM_SlaveMode_Reset
   1738          *                       - TIM_SlaveMode_Gated
   1739          *                       - TIM_SlaveMode_Trigger
   1740          *                       - TIM_SlaveMode_External1
   1741          * Output         : None
   1742          * Return         : None
   1743          *******************************************************************************/
   1744          void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, u16 TIM_SlaveMode)
   1745          {
   1746            u32 tmpsmcr = 0;
   1747          
   1748            /* Check the parameters */
   1749            assert(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
   1750          
   1751            tmpsmcr = TIMx->SMCR;
   1752          
   1753            /* Reset the SMS Bits */
   1754            tmpsmcr &= SMCR_SMS_Mask;
   1755          
   1756            /* Select the Slave Mode */
   1757            tmpsmcr |= TIM_SlaveMode;
   1758          
   1759            TIMx->SMCR = (u16)tmpsmcr;
   1760          }
   1761          
   1762          /*******************************************************************************
   1763          * Function Name  : TIM_SelectMasterSlaveMode
   1764          * Description    : Sets or Resets the TIMx Master/Slave Mode.
   1765          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1766          *                  - TIM_MasterSlaveMode: specifies the Timer Master Slave Mode.
   1767          *                    This paramter can be one of the following values:
   1768          *                       - TIM_MasterSlaveMode_Enable: synchronization between the
   1769          *                         current timer and its slaves (through TRGO).
   1770          *                       - TIM_MasterSlaveMode_Disable: No action
   1771          * Output         : None
   1772          * Return         : None
   1773          *******************************************************************************/
   1774          void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, u16 TIM_MasterSlaveMode)
   1775          {
   1776            u32 tmpsmcr = 0;
   1777          
   1778            /* Check the parameters */
   1779            assert(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
   1780          
   1781            tmpsmcr = TIMx->SMCR;
   1782          
   1783            /* Set or Reset the MSM Bit */
   1784            tmpsmcr &= SMCR_MSM_Mask;
   1785            tmpsmcr |= TIM_MasterSlaveMode;
   1786          
   1787            TIMx->SMCR = (u16)tmpsmcr;
   1788          }
   1789          
   1790          /*******************************************************************************
   1791          * Function Name  : TIM_SetCounter
   1792          * Description    : Sets the TIMx Counter Register value
   1793          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1794          *                  - Counter: specifies the Counter register new value.
   1795          * Output         : None
   1796          * Return         : None
   1797          *******************************************************************************/
   1798          void TIM_SetCounter(TIM_TypeDef* TIMx, u16 Counter)
   1799          {
   1800            /* Set the Counter Register value */
   1801            TIMx->CNT = Counter;
   1802          }
   1803          
   1804          /*******************************************************************************
   1805          * Function Name  : TIM_SetAutoreload
   1806          * Description    : Sets the TIMx Autoreload Register value
   1807          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1808          *                  - Autoreload: specifies the Autoreload register new value.
   1809          * Output         : None
   1810          * Return         : None
   1811          *******************************************************************************/
   1812          void TIM_SetAutoreload(TIM_TypeDef* TIMx, u16 Autoreload)
   1813          {
   1814            /* Set the Autoreload Register value */
   1815            TIMx->ARR = Autoreload;
   1816          }
   1817          
   1818          /*******************************************************************************
   1819          * Function Name  : TIM_SetCompare1
   1820          * Description    : Sets the TIMx Capture Compare1 Register value
   1821          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1822          *                  - Compare1: specifies the Capture Compare1 register new value.
   1823          * Output         : None
   1824          * Return         : None
   1825          *******************************************************************************/
   1826          void TIM_SetCompare1(TIM_TypeDef* TIMx, u16 Compare1)
   1827          {
   1828            /* Set the Capture Compare1 Register value */
   1829            TIMx->CCR1 = Compare1;
   1830          }
   1831          
   1832          /*******************************************************************************
   1833          * Function Name  : TIM_SetCompare2
   1834          * Description    : Sets the TIMx Capture Compare2 Register value
   1835          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1836          *                  - Compare2: specifies the Capture Compare2 register new value.
   1837          * Output         : None
   1838          * Return         : None
   1839          *******************************************************************************/
   1840          void TIM_SetCompare2(TIM_TypeDef* TIMx, u16 Compare2)
   1841          {
   1842            /* Set the Capture Compare2 Register value */
   1843            TIMx->CCR2 = Compare2;
   1844          }
   1845          
   1846          /*******************************************************************************
   1847          * Function Name  : TIM_SetCompare3
   1848          * Description    : Sets the TIMx Capture Compare3 Register value
   1849          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1850          *                  - Compare3: specifies the Capture Compare3 register new value.
   1851          * Output         : None
   1852          * Return         : None
   1853          *******************************************************************************/
   1854          void TIM_SetCompare3(TIM_TypeDef* TIMx, u16 Compare3)
   1855          {
   1856            /* Set the Capture Compare3 Register value */
   1857            TIMx->CCR3 = Compare3;
   1858          }
   1859          
   1860          /*******************************************************************************
   1861          * Function Name  : TIM_SetCompare4
   1862          * Description    : Sets the TIMx Capture Compare4 Register value
   1863          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1864          *                  - Compare4: specifies the Capture Compare4 register new value.
   1865          * Output         : None
   1866          * Return         : None
   1867          *******************************************************************************/
   1868          void TIM_SetCompare4(TIM_TypeDef* TIMx, u16 Compare4)
   1869          {
   1870            /* Set the Capture Compare4 Register value */
   1871            TIMx->CCR4 = Compare4;
   1872          }
   1873          
   1874          /*******************************************************************************
   1875          * Function Name  : TIM_SetIC1Prescaler
   1876          * Description    : Sets the TIMx Input Capture 1 prescaler.
   1877          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1878          *                  - TIM_IC1Prescaler: specifies the Input Capture1 prescaler
   1879          *                    new value.
   1880          *                    This parameter can be one of the following values:
   1881          *                       - TIM_ICPSC_DIV1: no prescaler
   1882          *                       - TIM_ICPSC_DIV2: capture is done once every 2 events
   1883          *                       - TIM_ICPSC_DIV4: capture is done once every 4 events
   1884          *                       - TIM_ICPSC_DIV8: capture is done once every 8 events
   1885          * Output         : None
   1886          * Return         : None
   1887          *******************************************************************************/
   1888          void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, u16 TIM_IC1Prescaler)
   1889          {
   1890            u32 tmpccmr1 = 0;
   1891          
   1892            /* Check the parameters */
   1893            assert(IS_TIM_IC_PRESCALER(TIM_IC1Prescaler));
   1894          
   1895            tmpccmr1 = TIMx->CCMR1;
   1896          
   1897            /* Reset the IC1PSC Bits */
   1898            tmpccmr1 &= CCMR_IC13PSC_Mask;
   1899          
   1900            /* Set the IC1PSC value */
   1901            tmpccmr1 |= TIM_IC1Prescaler;
   1902          
   1903            TIMx->CCMR1 = (u16)tmpccmr1;
   1904          }
   1905          
   1906          /*******************************************************************************
   1907          * Function Name  : TIM_SetIC2Prescaler
   1908          * Description    : Sets the TIMx Input Capture 2 prescaler.
   1909          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1910          *                  - TIM_IC2Prescaler: specifies the Input Capture2 prescaler
   1911          *                    new value.
   1912          *                    This parameter can be one of the following values:
   1913          *                       - TIM_ICPSC_DIV1: no prescaler
   1914          *                       - TIM_ICPSC_DIV2: capture is done once every 2 events
   1915          *                       - TIM_ICPSC_DIV4: capture is done once every 4 events
   1916          *                       - TIM_ICPSC_DIV8: capture is done once every 8 events
   1917          * Output         : None
   1918          * Return         : None
   1919          *******************************************************************************/
   1920          void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, u16 TIM_IC2Prescaler)
   1921          {
   1922            u32 tmpccmr1 = 0;
   1923          
   1924            /* Check the parameters */
   1925            assert(IS_TIM_IC_PRESCALER(TIM_IC2Prescaler));
   1926          
   1927            tmpccmr1 = TIMx->CCMR1;
   1928          
   1929            /* Reset the IC2PSC Bits */
   1930            tmpccmr1 &= CCMR_IC24PSC_Mask;
   1931          
   1932            /* Set the IC2PSC value */
   1933            tmpccmr1 |= (u16)((u16)TIM_IC2Prescaler << 8);
   1934          
   1935            TIMx->CCMR1 = (u16)tmpccmr1;
   1936          }
   1937          
   1938          /*******************************************************************************
   1939          * Function Name  : TIM_SetIC3Prescaler
   1940          * Description    : Sets the TIMx Input Capture 3 prescaler.
   1941          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1942          *                  - TIM_IC3Prescaler: specifies the Input Capture3 prescaler
   1943          *                    new value.
   1944          *                    This parameter can be one of the following values:
   1945          *                       - TIM_ICPSC_DIV1: no prescaler
   1946          *                       - TIM_ICPSC_DIV2: capture is done once every 2 events
   1947          *                       - TIM_ICPSC_DIV4: capture is done once every 4 events
   1948          *                       - TIM_ICPSC_DIV8: capture is done once every 8 events
   1949          * Output         : None
   1950          * Return         : None
   1951          *******************************************************************************/
   1952          void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, u16 TIM_IC3Prescaler)
   1953          {
   1954            u32 tmpccmr2 = 0;
   1955          
   1956            /* Check the parameters */
   1957            assert(IS_TIM_IC_PRESCALER(TIM_IC3Prescaler));
   1958          
   1959            tmpccmr2 = TIMx->CCMR2;
   1960          
   1961            /* Reset the IC3PSC Bits */
   1962            tmpccmr2 &= CCMR_IC13PSC_Mask;
   1963          
   1964            /* Set the IC3PSC value */
   1965            tmpccmr2 |= TIM_IC3Prescaler;
   1966          
   1967            TIMx->CCMR2 = (u16)tmpccmr2;
   1968          }
   1969          
   1970          /*******************************************************************************
   1971          * Function Name  : TIM_SetIC4Prescaler
   1972          * Description    : Sets the TIMx Input Capture 4 prescaler.
   1973          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1974          *                  - TIM_IC4Prescaler: specifies the Input Capture4 prescaler
   1975          *                    new value.
   1976          *                    This parameter can be one of the following values:
   1977          *                      - TIM_ICPSC_DIV1: no prescaler
   1978          *                      - TIM_ICPSC_DIV2: capture is done once every 2 events
   1979          *                      - TIM_ICPSC_DIV4: capture is done once every 4 events
   1980          *                      - TIM_ICPSC_DIV8: capture is done once every 8 events
   1981          * Output         : None
   1982          * Return         : None
   1983          *******************************************************************************/
   1984          void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, u16 TIM_IC4Prescaler)
   1985          {
   1986            u32 tmpccmr2 = 0;
   1987             
   1988            /* Check the parameters */
   1989            assert(IS_TIM_IC_PRESCALER(TIM_IC4Prescaler));
   1990          
   1991            tmpccmr2 = TIMx->CCMR2;
   1992          
   1993            /* Reset the IC4PSC Bits */
   1994            tmpccmr2 &= CCMR_IC24PSC_Mask;
   1995          
   1996            /* Set the IC4PSC value */
   1997            tmpccmr2 |= (u16)((u16)TIM_IC4Prescaler << 8);
   1998          
   1999            TIMx->CCMR2 = (u16)tmpccmr2;
   2000          }
   2001          
   2002          /*******************************************************************************
   2003          * Function Name  : TIM_SetClockDivision
   2004          * Description    : Sets the TIMx Clock Division value.
   2005          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   2006          *                  - TIM_CKD: specifies the clock division value.
   2007          *                    This parameter can be one of the following value:
   2008          *                       - TIM_CKD_DIV1: TDTS = Tck_tim
   2009          *                       - TIM_CKD_DIV2: TDTS = 2*Tck_tim
   2010          *                       - TIM_CKD_DIV4: TDTS = 4*Tck_tim
   2011          * Output         : None
   2012          * Return         : None
   2013          *******************************************************************************/
   2014          void TIM_SetClockDivision(TIM_TypeDef* TIMx, u16 TIM_CKD)
   2015          {
   2016            u32 tmpcr1 = 0;
   2017          
   2018            /* Check the parameters */
   2019            assert(IS_TIM_CKD_DIV(TIM_CKD));
   2020          
   2021            tmpcr1 = TIMx->CR1;
   2022          
   2023            /* Reset the CKD Bits */
   2024            tmpcr1 &= CR1_CKD_Mask;
   2025          
   2026            /* Set the CKD value */
   2027            tmpcr1 |= TIM_CKD;
   2028          
   2029            TIMx->CR1 = (u16)tmpcr1;
   2030          }
   2031          
   2032          /*******************************************************************************
   2033          * Function Name  : TIM_GetCapture1
   2034          * Description    : Gets the TIMx Input Capture 1 value.
   2035          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   2036          * Output         : None
   2037          * Return         : Capture Compare 1 Register value.
   2038          *******************************************************************************/
   2039          u16 TIM_GetCapture1(TIM_TypeDef* TIMx)
   2040          {
   2041            /* Get the Capture 1 Register value */
   2042            return TIMx->CCR1;
   2043          }
   2044          
   2045          /*******************************************************************************
   2046          * Function Name  : TIM_GetCapture2
   2047          * Description    : Gets the TIMx Input Capture 2 value.
   2048          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   2049          * Output         : None
   2050          * Return         : Capture Compare 2 Register value.
   2051          *******************************************************************************/
   2052          u16 TIM_GetCapture2(TIM_TypeDef* TIMx)
   2053          {
   2054            /* Get the Capture 2 Register value */
   2055            return TIMx->CCR2;
   2056          }
   2057          
   2058          /*******************************************************************************
   2059          * Function Name  : TIM_GetCapture3
   2060          * Description    : Gets the TIMx Input Capture 3 value.
   2061          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   2062          * Output         : None
   2063          * Return         : Capture Compare 3 Register value.
   2064          *******************************************************************************/
   2065          u16 TIM_GetCapture3(TIM_TypeDef* TIMx)
   2066          {
   2067            /* Get the Capture 3 Register value */
   2068            return TIMx->CCR3;
   2069          }
   2070          
   2071          /*******************************************************************************
   2072          * Function Name  : TIM_GetCapture4
   2073          * Description    : Gets the TIMx Input Capture 4 value.
   2074          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   2075          * Output         : None
   2076          * Return         : Capture Compare 4 Register value.
   2077          *******************************************************************************/
   2078          u16 TIM_GetCapture4(TIM_TypeDef* TIMx)
   2079          {
   2080            /* Get the Capture 4 Register value */
   2081            return TIMx->CCR4;
   2082          }
   2083          
   2084          /*******************************************************************************
   2085          * Function Name  : TIM_GetCounter
   2086          * Description    : Gets the TIMx Counter value.
   2087          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   2088          * Output         : None
   2089          * Return         : Counter Register value.
   2090          *******************************************************************************/
   2091          u16 TIM_GetCounter(TIM_TypeDef* TIMx)
   2092          {
   2093            /* Get the Counter Register value */
   2094            return TIMx->CNT;
   2095          }
   2096          
   2097          /*******************************************************************************
   2098          * Function Name  : TIM_GetPrescaler
   2099          * Description    : Gets the TIMx Prescaler value.
   2100          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   2101          * Output         : None
   2102          * Return         : Prescaler Register value.
   2103          *******************************************************************************/
   2104          u16 TIM_GetPrescaler(TIM_TypeDef* TIMx)
   2105          {
   2106            /* Get the Prescaler Register value */
   2107            return TIMx->PSC;
   2108          }
   2109          
   2110          /*******************************************************************************
   2111          * Function Name  : TIM_GetFlagStatus
   2112          * Description    : Checks whether the specified TIMx flag is set or not.
   2113          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   2114          *                  - TIM_FLAG: specifies the flag to check.
   2115          *                    This parameter can be one of the following values:
   2116          *                       - TIM_FLAG_Update: Timer update Flag
   2117          *                       - TIM_FLAG_CC1: Timer Capture Compare 1 Flag
   2118          *                       - TIM_FLAG_CC2: Timer Capture Compare 2 Flag
   2119          *                       - TIM_FLAG_CC3: Timer Capture Compare 3 Flag
   2120          *                       - TIM_FLAG_CC4: Timer Capture Compare 4 Flag
   2121          *                       - TIM_FLAG_Trigger: Timer Trigger Flag
   2122          *                       - TIM_FLAG_CC1OF: Timer Capture Compare 1 overcapture Flag
   2123          *                       - TIM_FLAG_CC2OF: Timer Capture Compare 2 overcapture Flag
   2124          *                       - TIM_FLAG_CC3OF: Timer Capture Compare 3 overcapture Flag
   2125          *                       - TIM_FLAG_CC4OF: Timer Capture Compare 4 overcapture Flag
   2126          * Output         : None
   2127          * Return         : The new state of TIM_FLAG (SET or RESET).
   2128          *******************************************************************************/
   2129          FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, u16 TIM_FLAG)
   2130          {
   2131            FlagStatus bitstatus = RESET;
   2132          
   2133            /* Check the parameters */
   2134            assert(IS_TIM_GET_FLAG(TIM_FLAG));
   2135          
   2136            if ((TIMx->SR & TIM_FLAG) != (u16)RESET )
   2137            {
   2138              bitstatus = SET;
   2139            }
   2140            else
   2141            {
   2142              bitstatus = RESET;
   2143            }
   2144            return bitstatus;
   2145          }
   2146          
   2147          /*******************************************************************************
   2148          * Function Name  : TIM_ClearFlag
   2149          * Description    : Clears the TIMx's pending flags.
   2150          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   2151          *                  - TIM_FLAG: specifies the flag bit to clear.
   2152          *                    This parameter can be any combination of the following values:
   2153          *                       - TIM_FLAG_Update: Timer update Flag
   2154          *                       - TIM_FLAG_CC1: Timer Capture Compare 1 Flag
   2155          *                       - TIM_FLAG_CC2: Timer Capture Compare 2 Flag
   2156          *                       - TIM_FLAG_CC3: Timer Capture Compare 3 Flag
   2157          *                       - TIM_FLAG_CC4: Timer Capture Compare 4 Flag
   2158          *                       - TIM_FLAG_Trigger: Timer Trigger Flag
   2159          *                       - TIM_FLAG_CC1OF: Timer Capture Compare 1 overcapture Flag
   2160          *                       - TIM_FLAG_CC2OF: Timer Capture Compare 2 overcapture Flag
   2161          *                       - TIM_FLAG_CC3OF: Timer Capture Compare 3 overcapture Flag
   2162          *                       - TIM_FLAG_CC4OF: Timer Capture Compare 4 overcapture Flag
   2163          * Output         : None
   2164          * Return         : None
   2165          *******************************************************************************/
   2166          void TIM_ClearFlag(TIM_TypeDef* TIMx, u16 TIM_FLAG)
   2167          {
   2168            /* Check the parameters */
   2169            assert(IS_TIM_CLEAR_FLAG(TIM_FLAG));
   2170          
   2171            /* Clear the flags */
   2172            TIMx->SR &= (u16)~TIM_FLAG;
   2173          }
   2174          
   2175          /*******************************************************************************
   2176          * Function Name  : TIM_GetITStatus
   2177          * Description    : Checks whether the TIMx interrupt has occurred or not.
   2178          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   2179          *                  - TIM_IT: specifies the TIM interrupt source to check.
   2180          *                    This parameter can be one of the following values:
   2181          *                         - TIM_IT_Update: Timer update Interrupt source
   2182          *                         - TIM_IT_CC1: Timer Capture Compare 1 Interrupt source
   2183          *                         - TIM_IT_CC2: Timer Capture Compare 2 Interrupt source
   2184          *                         - TIM_IT_CC3: Timer Capture Compare 3 Interrupt source
   2185          *                         - TIM_IT_CC4: Timer Capture Compare 4 Interrupt source
   2186          *                         - TIM_IT_Trigger: Timer Trigger Interrupt source
   2187          * Output         : None
   2188          * Return         : The new state of the TIM_IT(SET or RESET).
   2189          *******************************************************************************/
   2190          ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, u16 TIM_IT)
   2191          {
   2192            ITStatus bitstatus = RESET;
   2193            
   2194            u16 itstatus = 0x0, itenable = 0x0;
   2195          
   2196            /* Check the parameters */
   2197            assert(IS_TIM_GET_IT(TIM_IT));
   2198            
   2199            itstatus = TIMx->SR & TIM_IT;
   2200            
   2201            itenable = TIMx->DIER & TIM_IT;
   2202          
   2203            if ((itstatus != (u16)RESET)  && (itenable != (u16)RESET))
   2204            {
   2205              bitstatus = SET;
   2206            }
   2207            else
   2208            {
   2209              bitstatus = RESET;
   2210            }
   2211            return bitstatus;
   2212          }
   2213          
   2214          /*******************************************************************************
   2215          * Function Name  : TIM_ClearITPendingBit
   2216          * Description    : Clears the TIMx's interrupt pending bits.
   2217          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   2218          *                  - TIM_IT: specifies the pending bit to clear.
   2219          *                    This parameter can be any combination of the following values:
   2220          *                       - TIM_IT_Update: Timer update Interrupt source
   2221          *                       - TIM_IT_CC1: Timer Capture Compare 1 Interrupt source
   2222          *                       - TIM_IT_CC2: Timer Capture Compare 2 Interrupt source
   2223          *                       - TIM_IT_CC3: Timer Capture Compare 3 Interrupt source
   2224          *                       - TIM_IT_CC4: Timer Capture Compare 4 Interrupt source
   2225          *                       - TIM_IT_Trigger: Timer Trigger Interrupt source
   2226          * Output         : None
   2227          * Return         : None
   2228          *******************************************************************************/
   2229          void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, u16 TIM_IT)
   2230          {
   2231            /* Check the parameters */
   2232            assert(IS_TIM_IT(TIM_IT));
   2233            
   2234            /* Clear the IT pending Bit */
   2235            TIMx->SR &= (u16)~TIM_IT;
   2236          }
   2237          
   2238          /*******************************************************************************
   2239          * Function Name  : PWMInput_Config
   2240          * Description    : Configures the TIM peripheral according to the specified
   2241          *                  parameters in the TIM_ICInitStruct to measure an external PWM
   2242          *                  signal.
   2243          * Input          : - TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
   2244          *                    that contains the configuration information for the specified
   2245          *                    TIM peripheral.
   2246          * Output         : None
   2247          * Return         : None
   2248          *******************************************************************************/
   2249          static void PWMI_Config(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
   2250          {
   2251            u8 ICPolarity = TIM_ICPolarity_Rising;
   2252            u8 ICSelection = TIM_ICSelection_DirectTI;
   2253          
   2254            /* Select the Opposite Input Polarity */
   2255            if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
   2256            {
   2257              ICPolarity = TIM_ICPolarity_Falling;
   2258            }
   2259            else
   2260            {
   2261              ICPolarity = TIM_ICPolarity_Rising;
   2262            }
   2263          
   2264            /* Select the Opposite Input */
   2265            if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
   2266            {
   2267              ICSelection = TIM_ICSelection_IndirectTI;
   2268            }
   2269            else
   2270            {
   2271              ICSelection = TIM_ICSelection_DirectTI;
   2272            }
   2273          
   2274            if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
   2275            {
   2276              /* TI1 Configuration */
   2277              TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
   2278                         TIM_ICInitStruct->TIM_ICFilter);
   2279          
   2280              /* Set the Input Capture Prescaler value */
   2281              TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   2282          
   2283              /* TI2 Configuration */
   2284              TI2_Config(TIMx, ICPolarity, ICSelection, TIM_ICInitStruct->TIM_ICFilter);
   2285          
   2286              /* Set the Input Capture Prescaler value */
   2287              TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   2288            }
   2289            else
   2290            {	 
   2291              /* TI1 Configuration */
   2292              TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
   2293                         TIM_ICInitStruct->TIM_ICFilter);
   2294          
   2295              /* Set the Input Capture Prescaler value */
   2296              TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   2297          
   2298              /* TI2 Configuration */
   2299              TI1_Config(TIMx, ICPolarity, ICSelection, TIM_ICInitStruct->TIM_ICFilter);
   2300          
   2301              /* Set the Input Capture Prescaler value */
   2302              TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   2303            }
   2304          }
   2305          
   2306          /*******************************************************************************
   2307          * Function Name  : TI1_Config
   2308          * Description    : Configure the TI1 as Input.
   2309          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   2310          *                  - TIM_ICPolarity : The Input Polarity.
   2311          *                    This parameter can be one of the following values:
   2312          *                       - TIM_ICPolarity_Rising
   2313          *                       - TIM_ICPolarity_Falling
   2314          *                  - TIM_ICSelection: specifies the input to be used.
   2315          *                    This parameter can be one of the following values:
   2316          *                       - TIM_ICSelection_DirectTI: TIM Input 1 is selected to
   2317          *                         be connected to IC1.
   2318          *                       - TIM_ICSelection_IndirectTI: TIM Input 1 is selected to
   2319          *                         be connected to IC2.
   2320          *                       - TIM_ICSelection_TRGI: TIM Input 1 is selected to be
   2321          *                         connected to TRGI.
   2322          *                  - TIM_ICFilter: Specifies the Input Capture Filter.
   2323          *                    This parameter must be a value between 0x00 and 0x0F.
   2324          * Output         : None
   2325          * Return         : None
   2326          *******************************************************************************/
   2327          static void TI1_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
   2328                                 u8 TIM_ICFilter)
   2329          {
   2330            u32 tmpccmr1 = 0, tmpccer = 0;
   2331          
   2332            tmpccmr1 = TIMx->CCMR1;
   2333            tmpccer = TIMx->CCER;
   2334          
   2335            /* Disable the Channel 1: Reset the CCE Bit */
   2336            TIMx->CCER &= CCER_CC1E_Reset;
   2337          
   2338            /* Select the Input and set the filter */
   2339            tmpccmr1 &= CCMR_CC13S_Mask & CCMR_IC13F_Mask;
   2340            tmpccmr1 |= TIM_ICSelection | (u16)((u16)TIM_ICFilter << 4);
   2341          
   2342            /* Select the Polarity  and set the CCE Bit */
   2343            tmpccer &= CCER_CC1P_Mask & CCER_CC1E_Mask;
   2344            tmpccer |= TIM_ICPolarity | CCER_CC1E_Set;
   2345          
   2346            TIMx->CCMR1 = 0x0000;
   2347            TIMx->CCMR1 = (u16)tmpccmr1;
   2348            TIMx->CCER = (u16)tmpccer;
   2349          }
   2350          
   2351          /*******************************************************************************
   2352          * Function Name  : TI2_Config
   2353          * Description    : Configure the TI2 as Input.
   2354          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   2355          *                  - TIM_ICPolarity : The Input Polarity.
   2356          *                    This parameter can be one of the following values:
   2357          *                       - TIM_ICPolarity_Rising
   2358          *                       - TIM_ICPolarity_Falling
   2359          *                  - TIM_ICSelection: specifies the input to be used.
   2360          *                    This parameter can be one of the following values:
   2361          *                       - TIM_ICSelection_DirectTI: TIM Input 2 is selected to
   2362          *                         be connected to IC2.
   2363          *                       - TIM_ICSelection_IndirectTI: TIM Input 2 is selected to
   2364          *                         be connected to IC1.
   2365          *                       - TIM_ICSelection_TRGI: TIM Input 2 is selected to be
   2366          *                         connected to TRGI.
   2367          *                  - TIM_ICFilter: Specifies the Input Capture Filter.
   2368          *                    This parameter must be a value between 0x00 and 0x0F.
   2369          * Output         : None
   2370          * Return         : None
   2371          *******************************************************************************/
   2372          static void TI2_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
   2373                                 u8 TIM_ICFilter)
   2374          {
   2375            u32 tmpccmr1 = 0, tmpccer = 0, tmp = 0;
   2376          
   2377            tmpccmr1 = TIMx->CCMR1;
   2378            tmpccer = TIMx->CCER;
   2379            tmp = (u16)((u16)TIM_ICPolarity << 4);
   2380          
   2381            /* Disable the Channel 2: Reset the CCE Bit */
   2382            TIMx->CCER &= CCER_CC2E_Reset;
   2383          
   2384            /* Select the Input and set the filter */
   2385            tmpccmr1 &= CCMR_CC24S_Mask & CCMR_IC24F_Mask;
   2386            tmpccmr1 |= (u16)((u16)TIM_ICFilter << 12);
   2387            tmpccmr1 |= (u16)((u16)TIM_ICSelection << 8);
   2388          
   2389            /* Select the Polarity  and set the CCE Bit */
   2390            tmpccer &= CCER_CC2P_Mask & CCER_CC2E_Mask;
   2391            tmpccer |=  tmp | CCER_CC2E_Set;
   2392          
   2393            TIMx->CCMR1 = (u16)tmpccmr1 ;
   2394            TIMx->CCER = (u16)tmpccer;
   2395          }
   2396          
   2397          /*******************************************************************************
   2398          * Function Name  : TI3_Config
   2399          * Description    : Configure the TI3 as Input.
   2400          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   2401          *                  - TIM_ICPolarity : The Input Polarity.
   2402          *                    This parameter can be one of the following values:
   2403          *                       - TIM_ICPolarity_Rising
   2404          *                       - TIM_ICPolarity_Falling
   2405          *                  - TIM_ICSelection: specifies the input to be used.
   2406          *                    This parameter can be one of the following values:
   2407          *                       - TIM_ICSelection_DirectTI: TIM Input 3 is selected to
   2408          *                         be connected to IC3.
   2409          *                       - TIM_ICSelection_IndirectTI: TIM Input 3 is selected to
   2410          *                         be connected to IC4.
   2411          *                       - TIM_ICSelection_TRGI: TIM Input 3 is selected to be
   2412          *                         connected to TRGI.
   2413          *                  - TIM_ICFilter: Specifies the Input Capture Filter.
   2414          *                    This parameter must be a value between 0x00 and 0x0F.
   2415          * Output         : None
   2416          * Return         : None
   2417          *******************************************************************************/
   2418          static void TI3_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
   2419                                 u8 TIM_ICFilter)
   2420          {
   2421            u32 tmpccmr2 = 0, tmpccer = 0, tmp = 0;
   2422          
   2423            tmpccmr2 = TIMx->CCMR2;
   2424            tmpccer = TIMx->CCER;
   2425            tmp = (u16)((u16)TIM_ICPolarity << 8);
   2426          
   2427            /* Disable the Channel 3: Reset the CCE Bit */
   2428            TIMx->CCER &= CCER_CC3E_Reset;
   2429          
   2430            /* Select the Input and set the filter */
   2431            tmpccmr2 &= CCMR_CC13S_Mask & CCMR_IC13F_Mask;
   2432            tmpccmr2 |= TIM_ICSelection | (u16)((u16)TIM_ICFilter << 4);
   2433          
   2434            /* Select the Polarity  and set the CCE Bit */
   2435            tmpccer &= CCER_CC1P_Mask & CCER_CC1E_Mask;
   2436            tmpccer |= tmp | CCER_CC3E_Set;
   2437          
   2438            TIMx->CCMR2 = (u16)tmpccmr2;
   2439            TIMx->CCER = (u16)tmpccer;
   2440          }
   2441          
   2442          /*******************************************************************************
   2443          * Function Name  : TI4_Config
   2444          * Description    : Configure the TI1 as Input.
   2445          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   2446          *                  - TIM_ICPolarity : The Input Polarity.
   2447          *                    This parameter can be one of the following values:
   2448          *                       - TIM_ICPolarity_Rising
   2449          *                       - TIM_ICPolarity_Falling
   2450          *                  - TIM_ICSelection: specifies the input to be used.
   2451          *                    This parameter can be one of the following values:
   2452          *                       - TIM_ICSelection_DirectTI: TIM Input 4 is selected to
   2453          *                         be connected to IC4.
   2454          *                       - TIM_ICSelection_IndirectTI: TIM Input 4 is selected to
   2455          *                         be connected to IC3.
   2456          *                       - TIM_ICSelection_TRGI: TIM Input 4 is selected to be
   2457          *                         connected to TRGI.
   2458          *                  - TIM_ICFilter: Specifies the Input Capture Filter.
   2459          *                    This parameter must be a value between 0x00 and 0x0F.
   2460          * Output         : None
   2461          * Return         : None
   2462          *******************************************************************************/
   2463          static void TI4_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
   2464                                 u8 TIM_ICFilter)
   2465          {
   2466            u32 tmpccmr2 = 0, tmpccer = 0, tmp = 0;
   2467          
   2468            tmpccmr2 = TIMx->CCMR2;
   2469            tmpccer = TIMx->CCER;
   2470            tmp = (u16)((u16)TIM_ICPolarity << 12);
   2471          
   2472            /* Disable the Channel 4: Reset the CCE Bit */
   2473            TIMx->CCER &= CCER_CC4E_Reset;
   2474          
   2475            /* Select the Input and set the filter */
   2476            tmpccmr2 &= CCMR_CC24S_Mask & CCMR_IC24F_Mask;
   2477            tmpccmr2 |= (u16)((u16)TIM_ICSelection << 8) | (u16)((u16)TIM_ICFilter << 12);
   2478          
   2479            /* Select the Polarity  and set the CCE Bit */
   2480            tmpccer &= CCER_CC4P_Mask & CCER_CC4E_Mask;
   2481            tmpccer |= tmp | CCER_CC4E_Set;
   2482          
   2483            TIMx->CCMR2 = (u16)tmpccmr2;
   2484            TIMx->CCER = (u16)tmpccer ;
   2485          }
   2486          
   2487          /******************* (C) COPYRIGHT 2007 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function                    CSTACK
     --------                    ------
     PWMI_Config                    20
     TI1_Config                     16
     TI2_Config                     16
     TI3_Config                     16
     TI4_Config                     16
     TIM_ARRPreloadConfig           12
     TIM_ClearFlag                  12
     TIM_ClearITPendingBit          12
     TIM_ClearOC1Ref                12
     TIM_ClearOC2Ref                12
     TIM_ClearOC3Ref                12
     TIM_ClearOC4Ref                12
     TIM_Cmd                        12
     TIM_CounterModeConfig          12
     TIM_DMACmd                     16
     TIM_DMAConfig                  16
     TIM_DeInit                      4
     TIM_ETRClockMode1Config        20
     TIM_ETRClockMode2Config        20
     TIM_ETRConfig                   8
     TIM_EncoderInterfaceConfig     20
     TIM_ForcedOC1Config            12
     TIM_ForcedOC2Config            12
     TIM_ForcedOC3Config            12
     TIM_ForcedOC4Config            12
     TIM_GenerateEvent              12
     TIM_GetCapture1                 0
     TIM_GetCapture2                 0
     TIM_GetCapture3                 0
     TIM_GetCapture4                 0
     TIM_GetCounter                  0
     TIM_GetFlagStatus              12
     TIM_GetITStatus                12
     TIM_GetPrescaler                0
     TIM_ICInit                     12
     TIM_ICStructInit                0
     TIM_ITConfig                   16
     TIM_ITRxExternalClockConfig    12
     TIM_InternalClockConfig         0
     TIM_OC1FastConfig              12
     TIM_OC1PolarityConfig          12
     TIM_OC1PreloadConfig           12
     TIM_OC2FastConfig              12
     TIM_OC2PolarityConfig          12
     TIM_OC2PreloadConfig           12
     TIM_OC3FastConfig              12
     TIM_OC3PolarityConfig          12
     TIM_OC3PreloadConfig           12
     TIM_OC4FastConfig              12
     TIM_OC4PolarityConfig          12
     TIM_OC4PreloadConfig           12
     TIM_OCInit                     12
     TIM_OCStructInit                0
     TIM_PrescalerConfig            16
     TIM_SelectCCDMA                12
     TIM_SelectHallSensor           12
     TIM_SelectInputTrigger         12
     TIM_SelectMasterSlaveMode      12
     TIM_SelectOnePulseMode         12
     TIM_SelectOutputTrigger        12
     TIM_SelectSlaveMode            12
     TIM_SetAutoreload               0
     TIM_SetClockDivision           12
     TIM_SetCompare1                 0
     TIM_SetCompare2                 0
     TIM_SetCompare3                 0
     TIM_SetCompare4                 0
     TIM_SetCounter                  0
     TIM_SetIC1Prescaler            12
     TIM_SetIC2Prescaler            12
     TIM_SetIC3Prescaler            12
     TIM_SetIC4Prescaler            12
     TIM_TIxExternalClockConfig     20
     TIM_TimeBaseInit               12
     TIM_TimeBaseStructInit          0
     TIM_UpdateDisableConfig        12
     TIM_UpdateRequestConfig        12


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     Tab_OCModeMask                    8
     Tab_PolarityMask                  8
     TIM_DeInit                       88
     TIM_TimeBaseInit                108
     TIM_OCInit                      364
     TIM_ICInit                      292
     TIM_TimeBaseStructInit           18
     TIM_OCStructInit                 18
     TIM_ICStructInit                 26
     TIM_Cmd                          52
     TIM_ITConfig                     68
     TIM_DMAConfig                   264
     TIM_DMACmd                       80
     TIM_InternalClockConfig          10
     TIM_ITRxExternalClockConfig      52
     TIM_TIxExternalClockConfig      116
     TIM_ETRClockMode1Config         120
     TIM_ETRClockMode2Config          96
     TIM_ETRConfig                    32
     TIM_SelectInputTrigger           68
     TIM_PrescalerConfig              56
     TIM_CounterModeConfig            56
     TIM_ForcedOC1Config              44
     TIM_ForcedOC2Config              48
     TIM_ForcedOC3Config              40
     TIM_ForcedOC4Config              52
     TIM_ARRPreloadConfig             56
     TIM_SelectCCDMA                  48
     TIM_OC1PreloadConfig             44
     TIM_OC2PreloadConfig             52
     TIM_OC3PreloadConfig             42
     TIM_OC4PreloadConfig             52
     TIM_OC1FastConfig                44
     TIM_OC2FastConfig                48
     TIM_OC3FastConfig                44
     TIM_OC4FastConfig                52
     TIM_ClearOC1Ref                  44
     TIM_ClearOC2Ref                  48
     TIM_ClearOC3Ref                  44
     TIM_ClearOC4Ref                  48
     TIM_UpdateDisableConfig          56
     TIM_EncoderInterfaceConfig      148
     TIM_GenerateEvent                36
     TIM_OC1PolarityConfig            48
     TIM_OC2PolarityConfig            52
     TIM_OC3PolarityConfig            56
     TIM_OC4PolarityConfig            56
     TIM_UpdateRequestConfig          56
     TIM_SelectHallSensor             56
     TIM_SelectOnePulseMode           48
     TIM_SelectOutputTrigger          68
     TIM_SelectSlaveMode              52
     TIM_SelectMasterSlaveMode        48
     TIM_SetCounter                    4
     TIM_SetAutoreload                 4
     TIM_SetCompare1                   4
     TIM_SetCompare2                   4
     TIM_SetCompare3                   4
     TIM_SetCompare4                   6
     TIM_SetIC1Prescaler              52
     TIM_SetIC2Prescaler              60
     TIM_SetIC3Prescaler              52
     TIM_SetIC4Prescaler              60
     TIM_SetClockDivision             56
     TIM_GetCapture1                   4
     TIM_GetCapture2                   4
     TIM_GetCapture3                   4
     TIM_GetCapture4                   6
     TIM_GetCounter                    4
     TIM_GetPrescaler                  4
     TIM_GetFlagStatus                92
     TIM_ClearFlag                    40
     TIM_GetITStatus                  84
     TIM_ClearITPendingBit            36
     PWMI_Config                     140
     TI1_Config                       66
     TI2_Config                       84
     TI3_Config                       72
     TI4_Config                       84
     ??DataTable5                      4
     ??DataTable6                      4
     ??DataTable7                      4
     ??DataTable8                      4
     ??DataTable14                     4
     ??DataTable16                     4
     ??DataTable29                     4
     ??DataTable30                     4
     ??DataTable35                     4
     ??DataTable43                     4
     ??DataTable45                     4
     ??DataTable47                     4
     ??DataTable55                     4
     ??DataTable56                     4
     ??DataTable57                     4
     ??DataTable63                     4
     ??DataTable65                     4
     ??DataTable70                     4
     ??DataTable77                     4
     ??DataTable81                     4
     ??DataTable88                     4
     ??DataTable95                     4
     ??DataTable97                     4
     ??DataTable98                     4
     ??DataTable102                    4
     ??DataTable103                    4
     ??DataTable104                    4
     ??DataTable107                    4
     ??DataTable109                    4
     ??DataTable110                    4
     ??DataTable111                    4
     ??DataTable112                    4
     ??DataTable113                    4
     ?<Constant "C:\\David JIANG\\ST MCU...">
                                      88
      Others                          16

 
 4 792 bytes in segment CODE
   104 bytes in segment DATA_C
 
 4 776 bytes of CODE  memory (+ 16 bytes shared)
   104 bytes of CONST memory

Errors: none
Warnings: none
